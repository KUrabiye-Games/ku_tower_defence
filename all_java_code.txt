package com.kurabiye.kutd.DynamicArrayList;

import org.junit.jupiter.api.Test;

import org.junit.jupiter.api.BeforeAll;
import static org.junit.jupiter.api.Assertions.*;



public class DynamicArrayListTest {





}
package com.kurabiye.kutd.util.ObserverPattern;

public interface Observable {

    void addObserver(Observer observer);

    void removeObserver(Observer observer);

    void notifyObservers(Object arg);

}
package com.kurabiye.kutd.util.ObserverPattern;

public interface Observer {

    void update(Object arg);

}
package com.kurabiye.kutd.util.FactoryPattern;

public interface GenericFactory<T> {
    // This interface defines a factory method for creating objects of type T
    T create(); // Method to create an object of type T

}
package com.kurabiye.kutd.util.FactoryPattern;

public interface EnumFactory<T, E extends Enum<E>> {
    // This interface defines a factory method for creating objects of type T
    T create(E type); // Method to create an object of type T

}
package com.kurabiye.kutd.util.FactoryPattern;

public interface CodeFactory<T> {

    // This interface defines a factory method for creating objects of type T
    T create(int code); // Method to create an object of type T
    // This method is used to create an object of type T
    // The implementation of this method will be provided by the classes that implement this interface

}
package com.kurabiye.kutd.DynamicList;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class DynamicArrayList<T> extends ArrayList<T> {

    // This class extends ArrayList to create a dynamic array that can grow as needed
    // It can be used to store objects of any type with deferred operations during iteration
    
    private Set<T> pendingRemovals = new HashSet<>();
    private ArrayList<T> pendingAdditions = new ArrayList<>();

    public DynamicArrayList() {
        super(); // Call the constructor of ArrayList
    }    /**
     * Regular add method - adds item immediately to the list
     */
    @Override
    public boolean add(T item) {
        return super.add(item);
    }
    
    /**
     * Regular remove method - removes item immediately from the list
     */
    @Override
    public boolean remove(Object item) {
        boolean result = super.remove(item);
        // Also remove from pending operations if it was there
        pendingRemovals.remove(item);
        pendingAdditions.remove(item);
        return result;
    }
    
    /**
     * Marks an item for removal. The actual removal happens when removeCommit() is called.
     * This allows safe removal during iteration.
     * @param item The item to mark for removal
     */
    public void removeLater(T item) {
        pendingRemovals.add(item);
    }
    
    /**
     * Commits all pending removals, actually removing the marked items from the list.
     */
    public void removeCommit() {
        for (T item : pendingRemovals) {
            super.remove(item);
        }
        pendingRemovals.clear();
    }
    
    /**
     * Stages an item for addition. The actual addition happens when commitAdd() is called.
     * @param item The item to stage for addition
     */
    public void addLater(T item) {
        pendingAdditions.add(item);
    }
    
    /**
     * Commits all pending additions, actually adding the staged items to the list.
     */
    public void addCommit() {
        for (T item : pendingAdditions) {
            super.add(item);
        }
        pendingAdditions.clear();
    }
    
    /**
     * Returns an iterator that skips items marked for removal and doesn't show staged additions.
     * This provides a consistent view during iteration even when items are marked for operations.
     */
    @Override
    public Iterator<T> iterator() {
        return new DeferredOperationIterator();
    }
    
    /**
     * Gets the number of pending removals
     * @return Number of items marked for removal
     */
    public int getPendingRemovalCount() {
        return pendingRemovals.size();
    }
    
    /**
     * Gets the number of pending additions
     * @return Number of items staged for addition
     */
    public int getPendingAdditionCount() {
        return pendingAdditions.size();
    }
      /**
     * Checks if an item is marked for removal
     * @param item The item to check
     * @return true if the item is marked for removal
     */
    public boolean isMarkedForRemoval(T item) {
        return pendingRemovals.contains(item);
    }
    
    /**
     * Clears all pending operations without committing them
     */
    public void clearPendingOperations() {
        pendingRemovals.clear();
        pendingAdditions.clear();
    }
    
    /**
     * Custom iterator that provides a consistent view during iteration by skipping
     * items marked for removal
     */
    private class DeferredOperationIterator implements Iterator<T> {
        private Iterator<T> baseIterator;
        private T nextItem;
        private boolean hasNext;
        
        public DeferredOperationIterator() {
            baseIterator = DynamicArrayList.super.iterator();
            advance();
        }
        
        private void advance() {
            hasNext = false;
            while (baseIterator.hasNext()) {
                T item = baseIterator.next();
                if (!pendingRemovals.contains(item)) {
                    nextItem = item;
                    hasNext = true;
                    break;
                }
            }
        }
        
        @Override
        public boolean hasNext() {
            return hasNext;
        }
        
        @Override
        public T next() {
            if (!hasNext) {
                throw new java.util.NoSuchElementException();
            }
            T current = nextItem;
            advance();
            return current;
        }
          @Override
        public void remove() {
            // Allow normal iterator removal - it will work with the underlying ArrayList
            baseIterator.remove();
        }
    }

}
package com.kurabiye.kutd.controller;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;


public class ControllerTest {
  
 
    
}
// package com.kurabiye.kutd.controller;

// import com.kurabiye.kutd.view.MapEditorView;
// import com.kurabiye.kutd.model.MapManager;

// public class MapEditorController {
//     private MapEditorView mapEditorView;
//     private MapManager mapManager;
//     private MapPersistenceManager mapPersistenceManager;

//     public MapEditorController( MapManager mapManager) {
       
//     }

//     private void onTilePlaced(int x, int y, String tileType) {
//         boolean success = mapManager.placeTile(x, y, tileType);
//         if (success) {
//             mapEditorView.updateTile(x, y, tileType);
//         } else {
//             mapEditorView.showError("Cannot place tile here.");
//         }
//     }

//     private void onTileRemoved(int x, int y) {
//         boolean success = mapManager.removeTile(x, y);
//         if (success) {
//             mapEditorView.clearTile(x, y);
//         } else {
//             mapEditorView.showError("No tile to remove here.");
//         }
//     }

//     private void onSaveMap(String mapName) {
//         boolean success = mapPersistenceManager.saveMap(mapName, mapEditor.getCurrentMapGrid());
//         if (success) {
//             mapEditorView.showSuccess("Map saved successfully!");
//         } else {
//             mapEditorView.showError("Failed to save map.");
//         }
//     }

//     private void onLoadMap(String mapName) {
//         var loadedMapGrid = mapPersistenceManager.loadMap(mapName);
//         if (loadedMapGrid != null) {
//             mapEditor.setMapGrid(loadedMapGrid);
//             mapEditorView.displayMap(loadedMapGrid);
//         } else {
//             mapEditorView.showError("Failed to load map.");
//         }
//     }

//     private void onClearMap() {
//         mapManager.clearMap();
//         mapEditorView.displayMap(mapManager.getCurrentMapGrid());
//     }
// }

package com.kurabiye.kutd.controller;

public class MainMenuController {
    private final SettingsController settingsController;

    public MainMenuController() {
        
        this.settingsController = new SettingsController();

    }

    // Called when the "Play Game" button is pressed
    public GamePlayController onPlayButtonPressed() {
       
        GamePlayController gamePlayController = new GamePlayController();
        return gamePlayController;
    }


    // Called when the "Settings" button is clicked (can be implemented later)
    public SettingsController onSettingsButtonPressed() {
        
        SettingsController settingsController = new SettingsController();
        return settingsController;
    }

    // Called when the "Quit" button is clicked
    public void quitGame() {
      
        System.exit(0); // Exit the application
    }
}
package com.kurabiye.kutd.controller;


public abstract class Controller {
    public Controller() {
        initialize();
    }
    
    protected abstract void initialize();
}
package com.kurabiye.kutd.controller;

import com.kurabiye.kutd.model.Player.UserPreference;
import com.kurabiye.kutd.persistence.SettingsRepository;

public class SettingsController {
    private final SettingsRepository settingsRepository;

    public SettingsController() {
        this.settingsRepository = SettingsRepository.getInstance();
        loadSavedSettings();
    }

    private void loadSavedSettings() {
        UserPreference savedSettings = settingsRepository.loadSettings();
        if (savedSettings != null) {
            UserPreference.applySettings(new UserPreference.Builder(savedSettings));
        }
    }

    public UserPreference getCurrentPreferences() {
        return UserPreference.getInstance();
    }

    public void applyPreferences(UserPreference.Builder builder) {
        UserPreference.applySettings(builder);
        settingsRepository.saveSettings(UserPreference.getInstance());
    }

    public void resetPreferencesToDefault() {
        UserPreference.resetInstance();
        UserPreference newInstance = UserPreference.getInstance();
        settingsRepository.saveSettings(newInstance);
    }
}package com.kurabiye.kutd.controller;

import com.kurabiye.kutd.model.Listeners.IGameUpdateListener;
import com.kurabiye.kutd.model.Managers.GameManager;
import com.kurabiye.kutd.util.ObserverPattern.Observer;
import com.kurabiye.kutd.model.Map.GameMap;

public class GamePlayController {

    private final GameManager gameManager;

    public GameManager getGameManager() {
        return gameManager;
    }

    public GamePlayController() {

        GameMap defaultGameMap = GameMap.getPrebuiltMap();
        gameManager = new GameManager(defaultGameMap);
    }

    public void setGameUpdateListener(IGameUpdateListener listener) {

        this.gameManager.setGameUpdateListener(listener);
    }

    public void setPlayerObserver(Observer observer){
        this.gameManager.getPlayer().addObserver(observer);
    }

    public void setGameMapObserver(Observer observer){
        this.gameManager.getGameMap().addObserver(observer);
    }

    public void startGame() {
        gameManager.startGame(); // Starts the game thread and logic loop
    }

    public void pauseGame() {
        gameManager.pauseGame();
    }

    public void resumeGame() {
        gameManager.resumeGame();
    }

    public void endGame() {
        gameManager.endGame();
        terminateGameThread(); // Terminates the game thread
    }

    public void speedUpGame() {
        gameManager.speedUpGame();
    }

    public void slowDownGame() {
        gameManager.slowDownGame();
    }

    public boolean buildTower(int x, int y, int towerType) {
        return gameManager.buildTower(x, y, towerType);
    }

    public boolean sellTower(int x, int y, int towerType) {
        return gameManager.sellTower(x, y, towerType);
    }

    private void terminateGameThread() {
        gameManager.killGameThread();
    }

}
package com.kurabiye.kutd.persistence;


public class PersistenceTest {
  
 
    
}
package com.kurabiye.kutd.persistence;


public class Persistence {

}

package com.kurabiye.kutd.persistence;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.kurabiye.kutd.model.Player.UserPreference;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;

public class SettingsRepository {
    private static final String SETTINGS_DIR = System.getProperty("user.home") + "/.kutd/";
    private static final String SETTINGS_FILE = "settings.json";
    private static final ObjectMapper mapper = new ObjectMapper();
    
    private static SettingsRepository instance;
    
    // Private constructor to prevent instantiation
    private SettingsRepository() {}
    
    public static synchronized SettingsRepository getInstance() {
        if (instance == null) {
            instance = new SettingsRepository();
        }
        return instance;
    }
    
    public void saveSettings(UserPreference preferences) {
        try {
            Files.createDirectories(Paths.get(SETTINGS_DIR));
            File settingsFile = new File(SETTINGS_DIR + SETTINGS_FILE);
            mapper.writeValue(settingsFile, preferences);
        } catch (IOException e) {
            System.err.println("Failed to save settings: " + e.getMessage());
        }
    }
    
    public UserPreference loadSettings() {
        File settingsFile = new File(SETTINGS_DIR + SETTINGS_FILE);
        if (!settingsFile.exists()) {
            return null;
        }
        
        try {
            return mapper.readValue(settingsFile, UserPreference.class);
        } catch (IOException e) {
            System.err.println("Failed to load settings: " + e.getMessage());
            return null;
        }
    }
}package com.kurabiye.kutd.model.MapTest;

import org.junit.jupiter.api.Test;

import org.junit.jupiter.api.BeforeAll;
import static org.junit.jupiter.api.Assertions.*;



import com.kurabiye.kutd.model.Map.GameMap;
import com.kurabiye.kutd.model.Tile.Tile;
import com.kurabiye.kutd.model.Tile.TileFactory;
import com.kurabiye.kutd.model.Coordinates.TilePoint2D;

public class MapTest {

    
    
    private static TileFactory tileFactory;
    
    @BeforeAll
    public static void setUp() {
        tileFactory = new TileFactory();
    }
    
    @Test
    public void testMapInitialization() {
        GameMap map = new GameMap(); // Create a map of size 10x10
        assertNotNull(map, "Map should be initialized");
    }

    @Test
    public void testValidGameMap_ValidPath() {
        // Create a valid game map with path from left edge to right edge
        Tile[][] tiles = createBasicValidMap();
        TilePoint2D start = new TilePoint2D(6, 8); // Left edge
        TilePoint2D end = new TilePoint2D(12, 0); // Right edge


        
        GameMap map = new GameMap(tiles, start, end);

        map.buildTilePath();
        map.buildPointPath();


        assertTrue(map.isValidGameMap(), "Valid map should return true");
    }
              /*  
    @Test
    public void testValidGameMap_StartTileNotOnEdge() {
        // Test when starting tile is not on the edge
        Tile[][] tiles = createBasicValidMap();
        TilePoint2D start = new TilePoint2D(5, 4); // Not on edge
        TilePoint2D end = new TilePoint2D(15, 4); // Right edge
        
        GameMap map = new GameMap(tiles, start, end);
        assertFalse(map.isValidGameMap(), "Map with start tile not on edge should be invalid");
    }
 
    @Test
    public void testValidGameMap_EndTileNotOnEdge() {
        // Test when ending tile is not on the edge
        Tile[][] tiles = createBasicValidMap();
        TilePoint2D start = new TilePoint2D(0, 4); // Left edge
        TilePoint2D end = new TilePoint2D(10, 4); // Not on edge
        
        GameMap map = new GameMap(tiles, start, end);
        assertFalse(map.isValidGameMap(), "Map with end tile not on edge should be invalid");
    }
  
    @Test
    public void testValidGameMap_StartAndEndSameTile() {
        // Test when start and end tiles are the same
        Tile[][] tiles = createBasicValidMap();
        TilePoint2D start = new TilePoint2D(0, 4); // Left edge
        TilePoint2D end = new TilePoint2D(0, 4); // Same as start
        
        GameMap map = new GameMap(tiles, start, end);
        assertFalse(map.isValidGameMap(), "Map with same start and end tiles should be invalid");
    }

    @Test
    public void testValidGameMap_StartTileNotPath() {
        // Test when starting tile is not a path tile
        Tile[][] tiles = createBasicValidMap();
        tiles[4][0] = tileFactory.create(5); // Ground tile instead of path
        TilePoint2D start = new TilePoint2D(0, 4); // Left edge
        TilePoint2D end = new TilePoint2D(15, 4); // Right edge
        
        GameMap map = new GameMap(tiles, start, end);
        assertFalse(map.isValidGameMap(), "Map with non-path start tile should be invalid");
    }
 
    @Test
    public void testValidGameMap_EndTileNotPath() {
        // Test when ending tile is not a path tile
        Tile[][] tiles = createBasicValidMap();
        tiles[4][15] = tileFactory.create(5); // Ground tile instead of path
        TilePoint2D start = new TilePoint2D(0, 4); // Left edge
        TilePoint2D end = new TilePoint2D(15, 4); // Right edge
        
        GameMap map = new GameMap(tiles, start, end);
        assertFalse(map.isValidGameMap(), "Map with non-path end tile should be invalid");
    }
    
    @Test
    public void testValidGameMap_InsufficientBuildableTiles() {
        // Test when there are less than 4 buildable tiles
        Tile[][] tiles = createBasicValidMap();
        // Replace some buildable tiles with ground tiles
        for (int i = 0; i < GameMap.MAP_HEIGHT; i++) {
            for (int j = 0; j < GameMap.MAP_WIDTH; j++) {
                if (tiles[i][j].isBuildableTile()) {
                    tiles[i][j] = tileFactory.create(5); // Ground tile
                }
            }
        }
        // Add only 3 buildable tiles
        tiles[1][1] = tileFactory.create(15);
        tiles[1][2] = tileFactory.create(15);
        tiles[1][3] = tileFactory.create(15);
        
        TilePoint2D start = new TilePoint2D(0, 4); // Left edge
        TilePoint2D end = new TilePoint2D(15, 4); // Right edge
        
        GameMap map = new GameMap(tiles, start, end);
        assertFalse(map.isValidGameMap(), "Map with less than 4 buildable tiles should be invalid");
    }
    
    @Test
    public void testValidGameMap_ExactlyFourBuildableTiles() {
        // Test when there are exactly 4 buildable tiles
        Tile[][] tiles = createBasicValidMap();
        // Replace all buildable tiles with ground tiles
        for (int i = 0; i < GameMap.MAP_HEIGHT; i++) {
            for (int j = 0; j < GameMap.MAP_WIDTH; j++) {
                if (tiles[i][j].isBuildableTile()) {
                    tiles[i][j] = tileFactory.create(5); // Ground tile
                }
            }
        }
        // Add exactly 4 buildable tiles
        tiles[1][1] = tileFactory.create(15);
        tiles[1][2] = tileFactory.create(15);
        tiles[1][3] = tileFactory.create(15);
        tiles[1][4] = tileFactory.create(15);
        
        TilePoint2D start = new TilePoint2D(0, 4); // Left edge
        TilePoint2D end = new TilePoint2D(15, 4); // Right edge
        
        GameMap map = new GameMap(tiles, start, end);
        assertTrue(map.isValidGameMap(), "Map with exactly 4 buildable tiles should be valid");
    }
    
    @Test
    public void testValidGameMap_DisconnectedPath() {
        // Test when path is disconnected
        Tile[][] tiles = createBasicValidMap();
        // Break the path by replacing a middle tile with ground
        tiles[4][8] = tileFactory.create(5); // Ground tile breaks path
        
        TilePoint2D start = new TilePoint2D(0, 4); // Left edge
        TilePoint2D end = new TilePoint2D(15, 4); // Right edge
        
        GameMap map = new GameMap(tiles, start, end);
        assertFalse(map.isValidGameMap(), "Map with disconnected path should be invalid");
    }
    
    @Test
    public void testValidGameMap_NullTiles() {
        // Test when tiles array is null
        GameMap map = new GameMap(null, new TilePoint2D(0, 4), new TilePoint2D(15, 4));
        assertFalse(map.isValidGameMap(), "Map with null tiles should be invalid");
    }
    
    @Test
    public void testValidGameMap_NullStartCoordinates() {
        // Test when start coordinates are null
        Tile[][] tiles = createBasicValidMap();
        GameMap map = new GameMap(tiles, null, new TilePoint2D(15, 4));
        assertFalse(map.isValidGameMap(), "Map with null start coordinates should be invalid");
    }
    
    @Test
    public void testValidGameMap_NullEndCoordinates() {
        // Test when end coordinates are null
        Tile[][] tiles = createBasicValidMap();
        GameMap map = new GameMap(tiles, new TilePoint2D(0, 4), null);
        assertFalse(map.isValidGameMap(), "Map with null end coordinates should be invalid");
    }
    
    @Test
    public void testValidGameMap_TopEdgeStart() {
        // Test with start tile on top edge
        Tile[][] tiles = createVerticalPathMap();
        TilePoint2D start = new TilePoint2D(8, 0); // Top edge
        TilePoint2D end = new TilePoint2D(8, 8); // Bottom edge
        
        GameMap map = new GameMap(tiles, start, end);
        assertTrue(map.isValidGameMap(), "Map with start on top edge should be valid");
    }
    
    @Test
    public void testValidGameMap_BottomEdgeEnd() {
        // Test with end tile on bottom edge
        Tile[][] tiles = createVerticalPathMap();
        TilePoint2D start = new TilePoint2D(8, 0); // Top edge
        TilePoint2D end = new TilePoint2D(8, 8); // Bottom edge
        
        GameMap map = new GameMap(tiles, start, end);
        assertTrue(map.isValidGameMap(), "Map with end on bottom edge should be valid");
    }
    
    @Test
    public void testValidGameMap_InvalidWideStructure() {
        // Test with invalid wide structure (24-25-28-29 configuration)
        Tile[][] tiles = createBasicValidMap();
        // Place tile 24 at edge where it can't have proper configuration
        tiles[8][15] = tileFactory.create(24); // Can't have proper configuration at edge
        
        TilePoint2D start = new TilePoint2D(0, 4); // Left edge
        TilePoint2D end = new TilePoint2D(15, 4); // Right edge
        
        GameMap map = new GameMap(tiles, start, end);
        assertFalse(map.isValidGameMap(), "Map with invalid wide structure should be invalid");
    }
    
    @Test
    public void testValidGameMap_ValidWideStructure() {
        // Test with valid wide structure (24-25-28-29 configuration)
        Tile[][] tiles = createBasicValidMap();
        // Place proper 2x2 configuration
        tiles[1][1] = tileFactory.create(24);
        tiles[1][2] = tileFactory.create(25);
        tiles[2][1] = tileFactory.create(28);
        tiles[2][2] = tileFactory.create(29);
        
        TilePoint2D start = new TilePoint2D(0, 4); // Left edge
        TilePoint2D end = new TilePoint2D(15, 4); // Right edge
        
        GameMap map = new GameMap(tiles, start, end);
        assertTrue(map.isValidGameMap(), "Map with valid wide structure should be valid");
    }
    
    @Test
    public void testValidGameMap_OutOfBoundsCoordinates() {
        // Test with coordinates out of bounds
        //Tile[][] tiles = createBasicValidMap();
        
        assertThrows(IllegalArgumentException.class, () -> {
            new TilePoint2D(-1, 4); // Negative coordinates should throw exception
        }, "Negative coordinates should throw exception");
        
        assertThrows(IllegalArgumentException.class, () -> {
            new TilePoint2D(16, 4); // X coordinate out of bounds
        }, "X coordinate out of bounds should throw exception");
        
        assertThrows(IllegalArgumentException.class, () -> {
            new TilePoint2D(4, 9); // Y coordinate out of bounds
        }, "Y coordinate out of bounds should throw exception");
    }
    
    @Test
    public void testPrebuiltMapIsValid() {
        // Test that the prebuilt map is valid
        GameMap prebuiltMap = GameMap.getPrebuiltMap();
        assertNotNull(prebuiltMap, "Prebuilt map should not be null");
        assertTrue(prebuiltMap.isValidGameMap(), "Prebuilt map should be valid");
    }
    
    @Test
    public void testValidGameMap_PathConnectivity() {
        // Test path connectivity with a more complex path
        Tile[][] tiles = createComplexValidMap();
        TilePoint2D start = new TilePoint2D(0, 1); // Left edge
        TilePoint2D end = new TilePoint2D(15, 7); // Right edge
        
        GameMap map = new GameMap(tiles, start, end);
        assertTrue(map.isValidGameMap(), "Complex valid map should return true");
    }
    
    @Test
    public void testValidGameMap_CornerStartEnd() {
        // Test with start and end at corners
        Tile[][] tiles = createCornerPathMap();
        TilePoint2D start = new TilePoint2D(0, 0); // Top-left corner
        TilePoint2D end = new TilePoint2D(15, 8); // Bottom-right corner
        
        GameMap map = new GameMap(tiles, start, end);
        assertTrue(map.isValidGameMap(), "Map with corner start/end should be valid");
    }
    
    @Test
    public void testMapEditorRequirements() {
        // This test verifies all the map editor requirements mentioned in COMP 302 assignment
        
        // 1. The starting tile of the path is at the edge of the screen and marked as starting point
        Tile[][] tiles = createBasicValidMap();
        TilePoint2D edgeStart = new TilePoint2D(0, 4); // Left edge
        TilePoint2D centerStart = new TilePoint2D(5, 4); // Not on edge
        TilePoint2D validEnd = new TilePoint2D(15, 4); // Right edge
        
        GameMap validMap = new GameMap(tiles, edgeStart, validEnd);
        assertTrue(validMap.isValidGameMap(), "Map with edge start should be valid");
        
        GameMap invalidMap = new GameMap(tiles, centerStart, validEnd);
        assertFalse(invalidMap.isValidGameMap(), "Map with center start should be invalid");
        
        // 2. The ending tile of the path is at the edge of the screen and marked as ending point
        TilePoint2D edgeEnd = new TilePoint2D(15, 4); // Right edge
        TilePoint2D centerEnd = new TilePoint2D(10, 4); // Not on edge
        
        validMap = new GameMap(tiles, edgeStart, edgeEnd);
        assertTrue(validMap.isValidGameMap(), "Map with edge end should be valid");
        
        invalidMap = new GameMap(tiles, edgeStart, centerEnd);
        assertFalse(invalidMap.isValidGameMap(), "Map with center end should be invalid");
        
        // 3. The path is fully connected and does not contain discontinuities
        Tile[][] disconnectedTiles = createBasicValidMap();
        disconnectedTiles[4][8] = tileFactory.create(5); // Break the path
        
        GameMap disconnectedMap = new GameMap(disconnectedTiles, edgeStart, edgeEnd);
        assertFalse(disconnectedMap.isValidGameMap(), "Map with disconnected path should be invalid");
        
        // 4. There are at least four tiles with empty lots on which towers can be built during play
        Tile[][] insufficientBuildableTiles = createBasicValidMap();
        // Remove all buildable tiles
        for (int i = 0; i < GameMap.MAP_HEIGHT; i++) {
            for (int j = 0; j < GameMap.MAP_WIDTH; j++) {
                if (insufficientBuildableTiles[i][j].isBuildableTile()) {
                    insufficientBuildableTiles[i][j] = tileFactory.create(5); // Ground tile
                }
            }
        }
        // Add only 3 buildable tiles (less than required 4)
        insufficientBuildableTiles[1][1] = tileFactory.create(15);
        insufficientBuildableTiles[1][2] = tileFactory.create(15);
        insufficientBuildableTiles[1][3] = tileFactory.create(15);
        
        GameMap insufficientMap = new GameMap(insufficientBuildableTiles, edgeStart, edgeEnd);
        assertFalse(insufficientMap.isValidGameMap(), "Map with less than 4 buildable tiles should be invalid");
        
        // Valid map should have all requirements met
        assertTrue(validMap.isValidGameMap(), "Map meeting all requirements should be valid");
    }
    
    @Test
    public void testValidGameMap_AllEdgesStartEnd() {
        // Test all possible edge positions for start and end tiles
        
        // Top edge start to bottom edge end
        Tile[][] verticalTiles = createVerticalPathMap();
        GameMap topToBottom = new GameMap(verticalTiles, new TilePoint2D(8, 0), new TilePoint2D(8, 8));
        assertTrue(topToBottom.isValidGameMap(), "Top to bottom path should be valid");
        
        // Left edge start to right edge end (already tested in basic test)
        Tile[][] horizontalTiles = createBasicValidMap();
        GameMap leftToRight = new GameMap(horizontalTiles, new TilePoint2D(0, 4), new TilePoint2D(15, 4));
        assertTrue(leftToRight.isValidGameMap(), "Left to right path should be valid");
        
        // Corner combinations
        Tile[][] cornerTiles = createCornerPathMap();
        GameMap cornerPath = new GameMap(cornerTiles, new TilePoint2D(0, 0), new TilePoint2D(15, 8));
        assertTrue(cornerPath.isValidGameMap(), "Corner to corner path should be valid");
    }
    
    @Test
    public void testValidGameMap_EdgeValidation() {
        // Test edge validation logic more thoroughly
        Tile[][] tiles = createBasicValidMap();
        
        // Test all combinations of invalid positions (not on edges)
        TilePoint2D[] invalidPositions = {
            new TilePoint2D(1, 1), // Center
            new TilePoint2D(5, 3), // Center
            new TilePoint2D(8, 4), // Center
            new TilePoint2D(1, 7), // Not on any edge
        };
        
        TilePoint2D validEdgePosition = new TilePoint2D(0, 4); // Left edge
        
        for (TilePoint2D invalidPos : invalidPositions) {
            // Test invalid start position
            GameMap mapInvalidStart = new GameMap(tiles, invalidPos, validEdgePosition);
            assertFalse(mapInvalidStart.isValidGameMap(), 
                "Map with start at (" + invalidPos.getTileX() + "," + invalidPos.getTileY() + ") should be invalid");
            
            // Test invalid end position
            GameMap mapInvalidEnd = new GameMap(tiles, validEdgePosition, invalidPos);
            assertFalse(mapInvalidEnd.isValidGameMap(), 
                "Map with end at (" + invalidPos.getTileX() + "," + invalidPos.getTileY() + ") should be invalid");
        }
    }
    
    @Test
    public void testValidGameMap_BuildableTilesCounting() {
        // Test the exact counting of buildable tiles
        Tile[][] tiles = createBasicValidMap();
        
        // Count buildable tiles in our test map
        int buildableCount = 0;
        for (int i = 0; i < GameMap.MAP_HEIGHT; i++) {
            for (int j = 0; j < GameMap.MAP_WIDTH; j++) {
                if (tiles[i][j].isBuildableTile()) {
                    buildableCount++;
                }
            }
        }
        
        assertTrue(buildableCount >= 4, "Test map should have at least 4 buildable tiles");
        
        TilePoint2D start = new TilePoint2D(0, 4);
        TilePoint2D end = new TilePoint2D(15, 4);
        GameMap map = new GameMap(tiles, start, end);
        assertTrue(map.isValidGameMap(), "Map with " + buildableCount + " buildable tiles should be valid");
        
        // Test edge case: exactly 4 buildable tiles
        Tile[][] exactFourTiles = new Tile[GameMap.MAP_HEIGHT][GameMap.MAP_WIDTH];
        
        // Fill with ground tiles
        for (int i = 0; i < GameMap.MAP_HEIGHT; i++) {
            for (int j = 0; j < GameMap.MAP_WIDTH; j++) {
                exactFourTiles[i][j] = tileFactory.create(5); // Ground tile
            }
        }
        
        // Create path
        for (int j = 0; j < GameMap.MAP_WIDTH; j++) {
            exactFourTiles[4][j] = tileFactory.create(12); // Horizontal path
        }
        exactFourTiles[4][0] = tileFactory.create(2); // Start tile
        exactFourTiles[4][15] = tileFactory.create(1); // End tile
        
        // Add exactly 4 buildable tiles
        exactFourTiles[1][1] = tileFactory.create(15);
        exactFourTiles[1][2] = tileFactory.create(15);
        exactFourTiles[6][1] = tileFactory.create(15);
        exactFourTiles[6][2] = tileFactory.create(15);
        
        GameMap exactFourMap = new GameMap(exactFourTiles, start, end);
        assertTrue(exactFourMap.isValidGameMap(), "Map with exactly 4 buildable tiles should be valid");
    }

*/  
    private static final int[][] map = {
        { 5, 5, 5, 5, 16, 5, 17, 5, 5, 5, 24, 25, 7, 5, 5, 19 },
        { 0, 1, 2, 5, 0, 1, 2, 5, 5, 18, 28, 29, 6, 23, 16, 5 },
        { 4, 15, 7, 15, 7, 22, 8, 13, 13, 9, 1, 9, 10, 5, 5, 5 },
        { 8, 2, 8, 9, 10, 5, 5, 5, 5, 5, 5, 5, 5, 17, 27, 5 },
        { 5, 7, 19, 18, 5, 5, 5, 0, 1, 2, 15, 5, 5, 31, 5, 5},
        { 5, 7, 5, 5, 15, 0, 13, 10, 15, 8, 13, 2, 5, 5, 5, 5 },
        { 5, 4, 5, 0, 13, 10, 0, 1, 2, 5, 30, 6, 5, 5, 5, 5 },
        { 23, 7, 15, 7, 5, 5, 4, 18, 8, 13, 13, 10, 16, 5, 18, 5 },
        { 5, 8, 13, 10, 5, 5, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5 }
    };
 
 

    private Tile[][] createBasicValidMap() {

        int MAP_WIDTH = 16; // Width of the map
        int MAP_HEIGHT = 9; // Height of the map

        Tile[][] tiles = new Tile[MAP_HEIGHT][MAP_WIDTH]; // Initialize the tiles array
        TileFactory tileFactory = new TileFactory();

        // Create the tiles and set their properties
        for (int i = 0; i < MAP_HEIGHT; i++) {
            for (int j = 0; j < MAP_WIDTH; j++) {
                Tile tile = tileFactory.create(map[i][j]); // Create a new tile with code using factory
                tile.setCoordinate(new TilePoint2D(j, i)); // Set coordinates for the tile
                tiles[i][j] = tile;
            }
        }

        return tiles; // Return the static map
    }


    // Helper method to create a map with vertical path
    private Tile[][] createVerticalPathMap() {
        Tile[][] tiles = new Tile[GameMap.MAP_HEIGHT][GameMap.MAP_WIDTH];
        
        // Fill map with ground tiles
        for (int i = 0; i < GameMap.MAP_HEIGHT; i++) {
            for (int j = 0; j < GameMap.MAP_WIDTH; j++) {
                tiles[i][j] = tileFactory.create(5); // Ground tile
            }
        }
        
        // Create vertical path in the middle column (x=8)
        for (int i = 0; i < GameMap.MAP_HEIGHT; i++) {
            if (i == 0) {
                tiles[i][8] = tileFactory.create(3); // Path tile going down (1->3)
            } else if (i == GameMap.MAP_HEIGHT - 1) {
                tiles[i][8] = tileFactory.create(4); // Path tile going from up (1->3)
            } else {
                tiles[i][8] = tileFactory.create(11); // Vertical path tile (1->3)
            }
        }
        
        // Add buildable tiles (at least 4)
        tiles[1][1] = tileFactory.create(15);
        tiles[1][2] = tileFactory.create(15);
        tiles[2][1] = tileFactory.create(15);
        tiles[2][2] = tileFactory.create(15);
        tiles[6][6] = tileFactory.create(15);
        tiles[6][7] = tileFactory.create(15);
        
        return tiles;
    }
    
    // Helper method to create a complex valid map with curved path
    private Tile[][] createComplexValidMap() {
        Tile[][] tiles = new Tile[GameMap.MAP_HEIGHT][GameMap.MAP_WIDTH];
        
        // Fill map with ground tiles
        for (int i = 0; i < GameMap.MAP_HEIGHT; i++) {
            for (int j = 0; j < GameMap.MAP_WIDTH; j++) {
                tiles[i][j] = tileFactory.create(5); // Ground tile
            }
        }
        
        // Create L-shaped path: start at (0,1), go right to (5,1), then down to (5,7), then right to (15,7)
        // Start tile
        tiles[1][0] = tileFactory.create(2); // Going right
        
        // Horizontal segment
        for (int j = 1; j < 5; j++) {
            tiles[1][j] = tileFactory.create(12); // Horizontal path
        }
        
        // Corner tile
        tiles[1][5] = tileFactory.create(9); // Right to down
        
        // Vertical segment  
        for (int i = 2; i < 7; i++) {
            tiles[i][5] = tileFactory.create(11); // Vertical path
        }
        
        // Corner tile
        tiles[7][5] = tileFactory.create(1); // Down to right
        
        // Final horizontal segment
        for (int j = 6; j < 15; j++) {
            tiles[7][j] = tileFactory.create(12); // Horizontal path
        }
        
        // End tile
        tiles[7][15] = tileFactory.create(1); // From left
        
        // Add buildable tiles
        for (int i = 3; i < 6; i++) {
            for (int j = 7; j < 10; j++) {
                tiles[i][j] = tileFactory.create(15);
            }
        }
        
        return tiles;
    }
    
    // Helper method to create a map with corner path
    private Tile[][] createCornerPathMap() {
        Tile[][] tiles = new Tile[GameMap.MAP_HEIGHT][GameMap.MAP_WIDTH];
        
        // Fill map with ground tiles
        for (int i = 0; i < GameMap.MAP_HEIGHT; i++) {
            for (int j = 0; j < GameMap.MAP_WIDTH; j++) {
                tiles[i][j] = tileFactory.create(5); // Ground tile
            }
        }
        
        // Create diagonal-like path from top-left to bottom-right
        // Start at top-left corner
        tiles[0][0] = tileFactory.create(9); // Down and right
        
        // Go right along top edge
        for (int j = 1; j < 8; j++) {
            tiles[0][j] = tileFactory.create(12); // Horizontal path
        }
        
        // Turn down
        tiles[0][8] = tileFactory.create(9); // Right to down
        
        // Go down
        for (int i = 1; i < 8; i++) {
            tiles[i][8] = tileFactory.create(11); // Vertical path
        }
        
        // Turn right
        tiles[8][8] = tileFactory.create(1); // Down to right
        
        // Go right to end
        for (int j = 9; j < 15; j++) {
            tiles[8][j] = tileFactory.create(12); // Horizontal path
        }
        
        // End at bottom-right
        tiles[8][15] = tileFactory.create(1); // From left
        
        // Add buildable tiles
        tiles[2][2] = tileFactory.create(15);
        tiles[2][3] = tileFactory.create(15);
        tiles[3][2] = tileFactory.create(15);
        tiles[3][3] = tileFactory.create(15);
        tiles[5][5] = tileFactory.create(15);
        tiles[6][6] = tileFactory.create(15);
        
        return tiles;
    }

}
package com.kurabiye.kutd.model.Tower;

import java.util.ArrayList;
import java.util.List;

import com.kurabiye.kutd.model.Coordinates.Point2D;
import com.kurabiye.kutd.model.Coordinates.TilePoint2D;
import com.kurabiye.kutd.model.Enemy.Enemy;
import com.kurabiye.kutd.model.Enemy.IEnemy;
import com.kurabiye.kutd.model.Projectile.Projectile;

import com.kurabiye.kutd.model.Projectile.ProjectileFactory;
import com.kurabiye.kutd.model.Projectile.Projectile.ProjectileType;
import com.kurabiye.kutd.model.Tower.AttackStrategy.IAttackStrategy;


/* * Tower.java
 *  This class represents a tower in the tower defense game.
 * It handles the tower's attributes, attack strategy, and projectile creation.
 * 
 * 
 * @author Atlas Berk Polat
 * @version 2.0
 * @since 2025-05-13
 */


public class Tower implements ITower{


   
    private float range; // Range of the tower
    private float attackSpeed; // Attack speed of the tower

    private TilePoint2D tileCoordinate; // Coordinate of the tower on the map
    private IAttackStrategy attackStrategy; // Strategy for attacking enemies

    private Point2D attackPoint; // Point where the tower attacks

    private double lastAttackTime; // Time of the last attack
   
    //private int level; // Level of the tower maybe later
    private int sellReturn; // The amount of money returned when the tower is sold

    private ProjectileFactory projectileFactory = ProjectileFactory.getInstance(); // Factory for creating projectiles

    private ProjectileType projectileType; // Type of projectile used by the tower

    // Level up


    public Tower(int sellReturn, float range, float attackSpeed) {
        
        this.sellReturn = sellReturn; // Set the sell return of the tower
        this.range = range; // Set the range of the tower
        this.attackSpeed = attackSpeed; // Set the attack speed of the tower

    }

    public void setTileCoordinate(TilePoint2D tileCoordinate) {
        this.tileCoordinate = tileCoordinate; // Set the tile coordinate of the tower
        this.attackPoint = new Point2D(tileCoordinate.getCenter().getX(), (tileCoordinate.getCenter().getY() - TilePoint2D.getTileHeight() / 4 )); // Update the attack point of the tower
    }


    public void setProjectileType(ProjectileType projectileType) {
        this.projectileType = projectileType; // Set the projectile type
    }

    public ProjectileType getProjectileType() {
        return projectileType; // Get the projectile type
    }

    public void setAttackStrategy(IAttackStrategy attackStrategy) {
        this.attackStrategy = attackStrategy; // Set the attack strategy
    }
    public IAttackStrategy getAttackStrategy() {
        return attackStrategy; // Get the attack strategy
    }



    // and we will need to implement the attack method in the subclasses of the tower class
    @Override
    public Projectile attack(List<IEnemy> enemies, double deltaTime) {
        // Use the attack strategy to find the target enemy

        lastAttackTime += deltaTime; // Update the last attack time
        if (lastAttackTime < attackSpeed) {
            return null; // Not enough time has passed to attack
        }
        lastAttackTime = 0; // Reset the last attack time
        
        // Guard against empty lists
        if (enemies == null || enemies.isEmpty()) {
            return null; // No enemies to attack
        }

        // Filter the enemies based on the range of the tower
        ArrayList<IEnemy> filteredEnemies = enemies.stream()
                .filter(enemy -> enemy.getCoordinate().distance(tileCoordinate.getCenter()) <= range)
                .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);

        // If no enemies in range, return null
        if (filteredEnemies.isEmpty()) {
            return null; // No enemies in range
        }
        
        // Check if attackStrategy is null
        if (attackStrategy == null) {
           
            return null;
        }
        
        try {
            Enemy targetEnemy = (Enemy) attackStrategy.findTarget(filteredEnemies);

            if (targetEnemy == null) {
                return null; // No target found
            }
            
            // Create a projectile using the projectile factory
            // Add console logging for debugging
           
            
            Projectile projectile = projectileFactory.createProjectile(projectileType, attackPoint, targetEnemy.getCoordinate()); // Create a projectile using the factory

            // Check if the projectile's speed vector is zero

            if (projectile.getSpeedVector().magnitude() == 0) {
              
                return null; // No attack
            }
            return projectile; // Return the created projectile 
        } catch (Exception e) {
          
            e.printStackTrace();
            return null;
        }
    }

    public TilePoint2D getTileCoordinate() {
        return tileCoordinate; // Get the tile coordinate of the tower
    }

    /*public void setTileCoordinate(TilePoint2D tileCoordinate) { // In case we add a feature to move the tower
        this.tileCoordinate = tileCoordinate; // Set the tile coordinate of the tower
    }*/


    public synchronized int getSellReturn() {
        return sellReturn; // Get the sell return of the tower
    }

}
package com.kurabiye.kutd.model.Tower;

import java.util.List;

import com.kurabiye.kutd.model.Coordinates.TilePoint2D;

import com.kurabiye.kutd.model.Enemy.IEnemy;

import com.kurabiye.kutd.model.Projectile.Projectile;

import com.kurabiye.kutd.model.Projectile.Projectile.ProjectileType;
import com.kurabiye.kutd.model.Tower.AttackStrategy.IAttackStrategy;

/**
 * Interface defining the core functionality of a Tower in the tower defense game.
 * Towers are placed on the map and attack enemies within range.
 * 
 * @author Atlas Berk Polat
 * @version 1.2
 * @since 2025-05-02
 */
public interface ITower {
    
    /**
     * Attacks enemies within range and creates a projectile
     * 
     * @param enemies List of enemies that could be targeted
     * @param deltaTime Time passed since last update
     * @return Projectile created by the attack or null if no attack was performed
     */
    Projectile attack(List<IEnemy> enemies, double deltaTime);
    
    /**
     * Gets the tower's position on the map
     * 
     * @return The tile coordinates of the tower
     */
    TilePoint2D getTileCoordinate();
    
    /**
     * Sets the tower's position on the map
     * 
     * @param tileCoordinate The tile coordinates to place the tower
     */
    void setTileCoordinate(TilePoint2D tileCoordinate);
    
    /**
     * Gets the amount of gold returned when selling the tower
     * 
     * @return The sell return value
     */
    int getSellReturn();
    
    /**
     * Sets the attack strategy for the tower
     * 
     * @param attackStrategy The strategy to use for attacking enemies
     */
    void setAttackStrategy(IAttackStrategy attackStrategy);
    
    /**
     * Gets the attack strategy of the tower
     * 
     * @return The tower's attack strategy
     */
    IAttackStrategy getAttackStrategy();
    
    /**
     * Sets the projectile type that this tower will fire
     * 
     * @param projectileType The type of projectile
     */
    void setProjectileType(ProjectileType projectileType);

    /**
     * Gets the projectile type that this tower will fire
     * 
     * @return The type of projectile
     */
    ProjectileType getProjectileType();
}package com.kurabiye.kutd.model.Tower;


import com.kurabiye.kutd.model.Player.UserPreference;
import com.kurabiye.kutd.model.Projectile.Projectile.ProjectileType;
import com.kurabiye.kutd.model.Tower.AttackStrategy.ArcherStrategy;
import com.kurabiye.kutd.model.Tower.AttackStrategy.ArtilleryStrategy;
import com.kurabiye.kutd.model.Tower.AttackStrategy.MageStrategy;
import com.kurabiye.kutd.util.FactoryPattern.EnumFactory;

/*  TowerFactory.java
 *  This class is a singleton factory for creating different types of towers in the game.
 *  It uses the Singleton design pattern to ensure that only one instance of the factory exists.
 *  The factory creates towers based on the user's preferences and the type of tower requested.
 * 
 *   Tower types include:
 *   - ARTILLERY: Represents an artillery tower.
 *   - MAGE: Represents a mage tower.
 *   - ARCHER: Represents an archer tower.* 
 *   The factory uses the UserPreference class to get the user's preferences for tower attributes such as cost, attack power, range, and attack speed.
 * 
 *  The factory is designed to be used in a game where players can build and upgrade towers to defend against enemies.
 * 
 * @author Atlas Berk Polat
 * @version 1.0
 * @since 2025-04-23

* 
 *   The factory uses the UserPreference class to get the user's preferences for tower attributes such as cost, attack power, range, and attack speed.
 * 
 *  The factory is designed to be used in a game where players can build and upgrade towers to defend against enemies.
 * 
 * @author Atlas Berk Polat
 * @version 1.0
 * @since 2025-04-23
 */

public class TowerFactory implements EnumFactory<Tower, TowerFactory.TowerType> { // Implementing the Factory interface for Tower objects

    public enum TowerType {  // already static enum
        ARTILLERY, // 0 // Artillery tower type
        MAGE, // 1 // Mage tower type
        ARCHER // 2 // Archer tower type
    }

    // Using volatile to ensure visibility across threads
    private static volatile TowerFactory instance = null; // Singleton instance

    private final UserPreference userPreferences; // User preferences object

    private TowerFactory(UserPreference userPreferences) {
        // Private constructor to prevent instantiation
        this.userPreferences = userPreferences; // Initialize user preferences
    }

    /**
     * Thread-safe singleton implementation using double-checked locking
     * @return The singleton instance of TowerFactory
     * @throws IllegalStateException if UserPreference is not initialized
     */
    public static TowerFactory getInstance() {
        // First check (no locking)
        if (instance == null) {
            // Lock for thread safety
            synchronized (TowerFactory.class) {
                // Second check (with locking)
                if (instance == null) {
                    // Check if userPreferences is null before creating the instance
                    UserPreference userPref = UserPreference.getInstance();
                    if(userPref == null) {
                        throw new IllegalStateException("UserPreference instance is not initialized.");
                    }
                    instance = new TowerFactory(userPref); // Initialize with user preferences
                }
            }
        }
        return instance;
    }
    
    /**
     * Resets the singleton instance (useful for testing)
     */
    public static synchronized void resetInstance() {
        instance = null;
    }

    /**
     * This method creates a tower of the specified type.
     * It uses the user preferences to set the tower's attributes such as cost, attack power, range, and attack speed.
     * 
     * @param type The type of tower to create (ARTILLERY, MAGE, ARCHER).
     * @return Tower object of the specified type.
     */
    @Override
    public Tower create(TowerType type) {
        
        
       
        Tower tower = null;


        
        switch(type) {
            case ARCHER:
                // Create archer tower with parameters from userPreferences
                tower = new Tower((int) (userPreferences.getTowerSellReturn()[0] * userPreferences.getTowerConstructionCost()[0][0]), 
                                        userPreferences.getTowerEffectiveRange()[0][0], 
                                        userPreferences.getTowerRateOfFire()[0][0]
                                        );
                tower.setAttackStrategy(new ArcherStrategy());
                tower.setProjectileType(ProjectileType.ARROW);
                // Set other properties from userPreferences
                break;

            case MAGE:
                // Create mage tower with parameters from userPreferences
                tower = new Tower((int) (userPreferences.getTowerSellReturn()[1] * userPreferences.getTowerConstructionCost()[0][2]), 
                                     userPreferences.getTowerEffectiveRange()[0][1], 
                                     userPreferences.getTowerRateOfFire()[0][1]
                                     );
                tower.setAttackStrategy(new MageStrategy());
                tower.setProjectileType(ProjectileType.MAGIC);
                // Set other properties from userPreferences
                break;

            case ARTILLERY:
                // Create artillery tower with parameters from userPreferences
                tower = new Tower((int) (userPreferences.getTowerSellReturn()[2] * userPreferences.getTowerConstructionCost()[0][1]), 
                                          userPreferences.getTowerEffectiveRange()[0][2], 
                                          userPreferences.getTowerRateOfFire()[0][2]
                                          );
                tower.setAttackStrategy(new ArtilleryStrategy());
                tower.setProjectileType(ProjectileType.ARTILLERY);
                // Set other properties from userPreferences
                break;
                
            
            default:
                throw new IllegalArgumentException("Invalid tower type: " + type);
                
        }

       
        
        return tower;
    }


}
package com.kurabiye.kutd.model.Tower.AttackStrategy;


import com.kurabiye.kutd.model.Enemy.IEnemy;
import java.util.List;

/**
 * AttackStrategy interface defines the strategy for attacking enemies.
 * It contains a method to perform the attack on a list of enemies.
 * The strategy also chooses the target enemy to attack. 
 * It might be the one with the lowest health, the closest one, or any other criteria.
 * The specific implementation of the attack strategy will be provided in the classes that implement this interface.
 * 
 * 
 * @author: Atlas Berk Polat
 * @version: 1.0
 * @since: 2025-04-23
 */

public interface IAttackStrategy {
    

    /**
     * Attack method to be implemented by concrete attack strategies.
     * The strategy chooses the target enemy to attack. 
     * It might be the one with the lowest health, the closest one, or any other criteria.
     * @param enemy List of enemies to attack.
     */
    IEnemy findTarget(List<IEnemy> enemy); 


}
package com.kurabiye.kutd.model.Tower.AttackStrategy;

import java.util.List;


import com.kurabiye.kutd.model.Enemy.IEnemy;

/**
 * MageStrategy class implements the IAttackStrategy interface.
 * This class defines the attack strategy for the Mage tower.
 * It extends the AttackStrategy class and provides a specific implementation for the Mage tower's attack strategy.
 * 
 * @author Atlas Berk Polat
 * @version 1.0
 * @since 2025-04-25
 */

public class MageStrategy implements IAttackStrategy {
    

    /**
     * findTarget method is responsible for finding the target enemy to attack.
     * The specific implementation of the attack strategy will be provided in this method.
     * 
     * @param enemy List of enemies to attack.
     * @return Enemy to be attacked by the Mage tower, or null if no valid target.
     */
    @Override
    public IEnemy findTarget(List<IEnemy> enemies) {
        if (enemies == null || enemies.isEmpty()) {
            return null;
        }
        // For a more advanced implementation, this could target the strongest enemy
        // or the enemy with the highest health
        return enemies.get(0);
    }

}
package com.kurabiye.kutd.model.Tower.AttackStrategy;

import java.util.List;

import com.kurabiye.kutd.model.Enemy.IEnemy;


/**
 * MageStrategy class implements the IAttackStrategy interface.
 * This class defines the attack strategy for the Mage tower.
 * It extends the AttackStrategy class and provides a specific implementation for the Mage tower's attack strategy.
 * 
 * @author Atlas Berk Polat
 * @version 1.0
 * @since 2025-04-25
 */

public class ArtilleryStrategy implements IAttackStrategy {


    /**
     * findTarget method is responsible for finding the target enemy to attack.
     * The specific implementation of the attack strategy will be provided in this method.
     * 
     * @param enemy List of enemies to attack.
     * @return Enemy to be attacked by the Artillery tower, or null if no valid target.
     */
    @Override
    public IEnemy findTarget(List<IEnemy> enemies) {
        if (enemies == null || enemies.isEmpty()) {
            return null;
        }
        // Artillery could potentially target groups of enemies
        // For a more advanced implementation, this could find a cluster of enemies
        // or the enemy with the most other enemies nearby
        return enemies.get(0);
    }

}
package com.kurabiye.kutd.model.Tower.AttackStrategy;

import java.util.List;

import com.kurabiye.kutd.model.Enemy.IEnemy;

/**
 * ArcherStrategy class implements the IAttackStrategy interface.
 * This class defines the attack strategy for the Archer tower.
 * It extends the AttackStrategy class and provides a specific implementation for the Archer tower's attack strategy.
 * 
 * @author Atlas Berk Polat
 * @version 1.0
 * @since 2025-04-25
 */

public class ArcherStrategy implements IAttackStrategy {
    /**
     * findTarget method is responsible for finding the target enemy to attack.
     * The specific implementation of the attack strategy will be provided in this method.
     * 
     * @param enemy List of enemies to attack.
     * @return Enemy to be attacked by the tower, or null if no valid target.
     */
    @Override
    public IEnemy findTarget(List<IEnemy> enemies) {
        if (enemies == null || enemies.isEmpty()) {
            return null;
        }
        // For now, just return the first enemy in the list
        // In a more advanced implementation, this could select the enemy closest to the end
        // or with the lowest health, etc.
        return enemies.get(0);
    }
}
package com.kurabiye.kutd.model.Coordinates;

/**
 * This is the specific class that represents a tile coordinate in the game.
 * It extends our custom Point2D and adds tile-specific functionality.
 * It adjusts the tile sizes and the coordinates according to the map dimensions.
 * One can use this class to define the coordinates of the map tiles.
 * 
 * Each tile has 4 corners, and the coordinates are defined in pixels.
 * The map is divided into a grid of tiles, and each tile has a width and height. 
 * 
 * 
 * @author: Atlas Berk Polat
 * @version: 1.0
 * @since: 2025-04-23
 */
public class TilePoint2D extends Point2D {

    public static final int NUMBER_OF_TILES_X = 16; // The number of tiles in the x direction
    public static final int NUMBER_OF_TILES_Y = 9; // The number of tiles in the y direction

    public static final int MAP_WIDTH = 1920; // The width of the map in pixels
    public static final int MAP_HEIGHT = 1080; // The height of the map in pixels

    public static final int TILE_WIDTH = MAP_WIDTH / NUMBER_OF_TILES_X; // The width of each tile in pixels
    public static final int TILE_HEIGHT = MAP_HEIGHT / NUMBER_OF_TILES_Y; // The height of each tile in pixels

    private int tileX; // The x coordinate of the tile in the grid
    private int tileY; // The y coordinate of the tile in the grid

    private Point2D rightTopCorner;
    private Point2D rightBottomCorner;
    private Point2D leftTopCorner; // the super value store this coordinate
    private Point2D leftBottomCorner;

    private Point2D center; // the super value store this coordinate
 
    public TilePoint2D(int tileX, int tileY) {
        super(tileX * TILE_WIDTH, tileY * TILE_HEIGHT); // Convert the tile coordinates to pixel coordinates

        this.rightTopCorner = new Point2D((tileX + 1) * TILE_WIDTH, tileY * TILE_HEIGHT); // Calculate the right top corner
        this.rightBottomCorner = new Point2D((tileX + 1) * TILE_WIDTH, (tileY + 1) * TILE_HEIGHT); // Calculate the right bottom corner
        this.leftTopCorner = new Point2D(tileX * TILE_WIDTH, tileY * TILE_HEIGHT); // Calculate the left top corner
        this.leftBottomCorner = new Point2D(tileX * TILE_WIDTH, (tileY + 1) * TILE_HEIGHT); // Calculate the left bottom corner

        this.center = new Point2D((tileX + 0.5) * TILE_WIDTH, (tileY + 0.5) * TILE_HEIGHT); // Calculate the center of the tile

        this.tileX = tileX; // Set the tile x coordinate
        this.tileY = tileY; // Set the tile y coordinate
        
        // Check if the tile coordinates are within the bounds of the map
        if (tileX < 0 || tileX >= NUMBER_OF_TILES_X) {
            throw new IllegalArgumentException("Tile x coordinate is out of bounds: " + tileX);
        }
        if (tileY < 0 || tileY >= NUMBER_OF_TILES_Y) {
            throw new IllegalArgumentException("Tile y coordinate is out of bounds: " + tileY);
        }
    }

    public int getTileX() {
        return tileX; // Convert the pixel coordinates to tile coordinates
    }

    public int getTileY() {
        return tileY; // Convert the pixel coordinates to tile coordinates
    }

    public Point2D getRightTopCorner() {
        return rightTopCorner; // Get the right top corner of the tile
    }

    public Point2D getRightBottomCorner() {
        return rightBottomCorner; // Get the right bottom corner of the tile
    }

    public Point2D getLeftTopCorner() {
        return leftTopCorner; // Get the left top corner of the tile
    }

    public Point2D getLeftBottomCorner() {
        return leftBottomCorner; // Get the left bottom corner of the tile
    }

    public Point2D getCenter() {
        return center; // Get the center of the tile
    }

    public static int getTileWidth() {
        return TILE_WIDTH; // Get the width of the tile in pixels
    }

    public static int getTileHeight() {
        return TILE_HEIGHT; // Get the height of the tile in pixels
    }


    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true; // Check if the object is the same instance
        if (!(obj instanceof TilePoint2D)) return false; // Check if the object is of the same type

        TilePoint2D other = (TilePoint2D) obj; // Cast the object to TilePoint2D
        return tileX == other.getTileX() && tileY == other.getTileY(); // Check if the tile coordinates are equal
    }

    
    
   
}package com.kurabiye.kutd.model.Coordinates;

/**
 * A 2D geometric point that represents a location in (x,y) coordinate space.
 * This class is an alternative to JavaFX's Point2D, providing similar functionality
 * but contained within the project's own codebase.
 * 
 * We wanted to avoid using JavaFX's Point2D class to prevent unnecessary dependencies
 * 
 * @author JavaFX
 * @version 1.0
 * @since 2025-05-02
 */
public class Point2D {


    public static final Point2D ZER_POINT2D = new Point2D(0, 0); // A constant representing the origin point (0,0)
    
    private final double x; // The x coordinate
    private final double y; // The y coordinate
    
    /**
     * Creates a new instance of Point2D with the specified coordinates.
     * 
     * @param x the x coordinate
     * @param y the y coordinate
     */
    public Point2D(double x, double y) {
        this.x = x;
        this.y = y;
    }
    
    /**
     * Gets the x coordinate.
     * 
     * @return the x coordinate
     */
    public double getX() {
        return x;
    }
    
    /**
     * Gets the y coordinate.
     * 
     * @return the y coordinate
     */
    public double getY() {
        return y;
    }
    
    /**
     * Adds the specified coordinates to this point and returns the result as a new Point2D.
     * 
     * @param x the x coordinate to add
     * @param y the y coordinate to add
     * @return a new Point2D with the result of addition
     */
    public Point2D add(double x, double y) {
        return new Point2D(this.x + x, this.y + y);
    }
    
    /**
     * Adds the coordinates of the specified point to this point and returns the result as a new Point2D.
     * 
     * @param point the point whose coordinates are to be added
     * @return a new Point2D with the result of addition
     */
    public Point2D add(Point2D point) {
        return add(point.getX(), point.getY());
    }
    
    /**
     * Subtracts the specified coordinates from this point and returns the result as a new Point2D.
     * 
     * @param x the x coordinate to subtract
     * @param y the y coordinate to subtract
     * @return a new Point2D with the result of subtraction
     */
    public Point2D subtract(double x, double y) {
        return new Point2D(this.x - x, this.y - y);
    }
    
    /**
     * Subtracts the coordinates of the specified point from this point and returns the result as a new Point2D.
     * 
     * @param point the point whose coordinates are to be subtracted
     * @return a new Point2D with the result of subtraction
     */
    public Point2D subtract(Point2D point) {
        return subtract(point.getX(), point.getY());
    }
    
    /**
     * Multiplies this point's coordinates by the specified factor and returns the result as a new Point2D.
     * 
     * @param factor the factor to multiply by
     * @return a new Point2D with the result of multiplication
     */
    public Point2D multiply(double factor) {
        return new Point2D(x * factor, y * factor);
    }
    
    /**
     * Calculates the magnitude (length) of this point's vector from the origin.
     * 
     * @return the magnitude of the vector
     */
    public double magnitude() {
        return Math.sqrt(x * x + y * y);
    }
    
    /**
     * Returns a normalized version of this point as a new Point2D.
     * A normalized point has the same direction but a magnitude of 1.
     * 
     * @return a new Point2D with the normalized coordinates
     */
    public Point2D normalize() {
        double mag = magnitude();
        if (mag == 0) {
            return new Point2D(0, 0);
        }
        return new Point2D(x / mag, y / mag);
    }
    
    /**
     * Calculates the distance between this point and the specified coordinates.
     * 
     * @param x the x coordinate
     * @param y the y coordinate
     * @return the distance
     */
    public double distance(double x, double y) {
        double dx = this.x - x;
        double dy = this.y - y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    /**
     * Calculates the distance between this point and another point.
     * 
     * @param point the other point
     * @return the distance
     */
    public double distance(Point2D point) {
        return distance(point.getX(), point.getY());
    }
    
    /**
     * Calculates the dot product of this point and the specified coordinates.
     * 
     * @param x the x coordinate
     * @param y the y coordinate
     * @return the dot product
     */
    public double dotProduct(double x, double y) {
        return this.x * x + this.y * y;
    }
    
    /**
     * Calculates the dot product of this point and another point.
     * 
     * @param point the other point
     * @return the dot product
     */
    public double dotProduct(Point2D point) {
        return dotProduct(point.getX(), point.getY());
    }
    
    /**
     * Creates a new Point2D that is interpolated between this point and the specified point.
     * 
     * @param point the other point
     * @param t the interpolation parameter (0.0 for this point, 1.0 for the other point)
     * @return the interpolated point
     */
    public Point2D interpolate(Point2D point, double t) {
        double dx = point.getX() - this.x;
        double dy = point.getY() - this.y;
        return new Point2D(this.x + dx * t, this.y + dy * t);
    }
    
    /**
     * Returns a point that is the midpoint between this point and the specified point.
     * 
     * @param point the other point
     * @return the midpoint
     */
    public Point2D midpoint(Point2D point) {
        return interpolate(point, 0.5);
    }
    
    /**
     * Compares this point with the specified object for equality.
     * 
     * @param obj the object to compare with
     * @return true if the objects are the same or if the other object is a Point2D with the same coordinates
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        
        Point2D other = (Point2D) obj;
        // Using a small epsilon for floating point comparison
        final double EPSILON = 1e-10;
        return Math.abs(x - other.x) < EPSILON && Math.abs(y - other.y) < EPSILON;
    }
    
    /**
     * Returns a hash code for this point.
     * 
     * @return a hash code value
     */
    @Override
    public int hashCode() {
        long bits = java.lang.Double.doubleToLongBits(x);
        bits ^= java.lang.Double.doubleToLongBits(y) * 31;
        return (int) (bits ^ (bits >>> 32));
    }
    
    /**
     * Returns a string representation of this point.
     * 
     * @return a string representation
     */
    @Override
    public String toString() {
        return "Point2D[x=" + x + ", y=" + y + "]";
    }
}package com.kurabiye.kutd.model.Managers;

import java.util.Random;


import com.kurabiye.kutd.model.Player.UserPreference;
import com.kurabiye.kutd.model.Wave.WaveInfo;

/* WaveManager.java
 * This class is responsible for managing the waves of enemies in the game.
 * It holds the information about the current wave, the number of enemies in each wave,
 * the time between waves, and the type of enemies in each wave.
 * It gets the information from the UserPreferences.
 * 
 * 
 * @author: Atlas Berk Polat
 * @version: 1.0
 * @since: 2025-04-28
 */

public class WaveManager {


    Random random = new Random(); // Random number generator for enemy types

    // This number is not spesified in the user preferences, so it is hardcoded.
    // It is the time between enemy spawns in seconds.

    private static final double GRACE_WAIT_TIME = 1; // Time in milliseconds between waves
    private static final double ENEMY_SPAWN_TIME = 2; // Time in milliseconds between enemy spawns
    

    private WaveInfo waveInfo; // Wave information object

    private int currentWaveIndex = 0; // Current wave index
    private int currentGroupIndex = 0; // Current group index

    public enum EnemyAttackState { // Enum for wave states
        GRACE_PERIOD, // Grace period before the wave starts
        GROUP_WAITING, // Waiting for the next group to spawn
        SPAWNING, // Spawning enemies in the current group
        WAVE_WAITING, // Waiting for the next wave to start
        NO_ENEMY_LEFT // No enemies left to spawn

    }

    private EnemyAttackState waveState = EnemyAttackState.GRACE_PERIOD; // Current state of the wave

    

    private double lastGracePeriodTime = 0; // The Delta Time of the Last time the wave was spawned
    private double lastWaveWaitTime = 0; // The Delta Time of the Last time the wave was spawned
    private double lastGroupWaitTime = 0; // The Delta Time of the Last time the wave was spawned
    private double lastEnemySpawnTime = 0; // The Delta Time of the Last time the wave was spawned


    private int leftEnemiesInGroup = 0; // Number of enemies left in the current group

    private int[] currentGroupDecomposition; // Composition of types of enemies for a given group or wave



    public WaveManager(UserPreference userPreferences) {
        this.waveInfo = new WaveInfo(userPreferences); // Get the wave information from user preferences
    }

    /* This is the method that would keep track of the current wave and group index.
     * It will check if there is enough time passed to spawn a new wave or group.
     * Or enough time passed to spawn a new enemy.
     * 
     * 
     * @param deltaTime The time passed since the last update in milliseconds
     * *@return The index of the enemy to spawn or -1 if no enemy is spawned -2 if there is no enemy left to spawn
     * 
     */
    public int getEnemy(double deltaTime) {
        switch (waveState) {
            case GRACE_PERIOD:
                if (lastGracePeriodTime < GRACE_WAIT_TIME) { // If this is the first time the grace period is started
                    lastGracePeriodTime += deltaTime; // Set the last grace period time to the current time
                } else {
                    lastGracePeriodTime = 0; // Reset the last grace period time
                    waveState = EnemyAttackState.SPAWNING; // Change the state to group waiting
                    leftEnemiesInGroup = waveInfo.getTotalEnemyInGroup(0, 0); // Get the number of enemies in the current group
                    currentGroupDecomposition = waveInfo.getWaveGroupDecomposition(currentWaveIndex, currentGroupIndex);
                }
                return -1; // Placeholder for enemy spawning logic
                
            case SPAWNING:
                // check if there no is any enemy left to spawn in the current group
                if(leftEnemiesInGroup == 0){
                    // check if there is any group left to spawn in the current wave
                    if(currentGroupIndex < waveInfo.getTotalNumberOfGroupsInWave(currentWaveIndex) - 1){
                        currentGroupIndex++; // Increment the group index
                        leftEnemiesInGroup = waveInfo.getTotalEnemyInGroup(currentWaveIndex, currentGroupIndex); // Get the number of enemies in the current group
                        currentGroupDecomposition = waveInfo.getWaveGroupDecomposition(currentWaveIndex, currentGroupIndex); // Get the decomposition of the current group
                        lastGroupWaitTime = 0; // Reset the last group wait time
                        waveState = EnemyAttackState.GROUP_WAITING; // Change the state to group waiting
                    } else {
                        // check if there is any wave left to spawn
                        if(currentWaveIndex < waveInfo.getTotalNumberOfWaves() - 1){
                            currentWaveIndex++; // Increment the wave index
                            currentGroupIndex = 0; // Reset the group index
                            leftEnemiesInGroup = waveInfo.getTotalEnemyInGroup(currentWaveIndex, currentGroupIndex); // Get the number of enemies in the current group
                            currentGroupDecomposition = waveInfo.getWaveGroupDecomposition(currentWaveIndex, currentGroupIndex); // Get the decomposition of the current group
                            lastWaveWaitTime = 0; // Reset the last wave wait time
                            waveState = EnemyAttackState.WAVE_WAITING; // Change the state to wave waiting
                        } else {
                            waveState = EnemyAttackState.NO_ENEMY_LEFT; // Change the state to no enemy left
                        }
                    }
                    return -1; // Placeholder for enemy spawning logic
                }

                if (lastEnemySpawnTime < ENEMY_SPAWN_TIME) { // If this is the first time the enemy spawn time is started
                    lastEnemySpawnTime += deltaTime; // Set the last enemy spawn time to the current time
                } else {
                    lastEnemySpawnTime = 0; // Reset the last enemy spawn time
                    leftEnemiesInGroup--; // Decrement the number of enemies left in the group

                    // Choose the enemy type based on the wave and group index

                    // Check if currentGroupDecomposition is null or empty
                    if (currentGroupDecomposition == null || currentGroupDecomposition.length == 0) {
                        return -1; // Return -1 indicating no enemy to spawn
                    }
                    
                    // Count available enemy types (those with values > 0)
                    int availableTypes = 0;
                    for (int count : currentGroupDecomposition) {
                        if (count > 0) availableTypes++;
                    }
                    
                    if (availableTypes == 0) {
                        return -1;
                    }
                    
                    int attempts = 0;
                    while (attempts < 100) { // Prevent infinite loop
                        int enemyTypeIndex = random.nextInt(currentGroupDecomposition.length); // Get a random enemy type index
                        if (currentGroupDecomposition[enemyTypeIndex] > 0) { // Check if the enemy type is available
                            currentGroupDecomposition[enemyTypeIndex]--; // Decrement the number of enemies of that type
                            return enemyTypeIndex; // Return the enemy type index to spawn
                        }
                        attempts++;
                    }
                    
                    return -1; // Fallback, should not reach here if the decomposition is valid
                }
                return -1;
                
            case GROUP_WAITING:
                if (lastGroupWaitTime < waveInfo.getDefaultDelayBetweenGroups()) { // If this is the first time the group wait time is started
                    lastGroupWaitTime += deltaTime; // Set the last group wait time to the current time
                } else {
                    lastGroupWaitTime = 0; // Reset the last group wait time
                    waveState = EnemyAttackState.SPAWNING; // Change the state to spawning
                }
                return -1; // Placeholder for enemy spawning logic
                
            case WAVE_WAITING:
                if (lastWaveWaitTime < waveInfo.getDefaultDelayBetweenWaves()) { // If this is the first time the wave wait time is started
                    lastWaveWaitTime += deltaTime; // Set the last wave wait time to the current time
                } else {
                    lastWaveWaitTime = 0; // Reset the last wave wait time
                    waveState = EnemyAttackState.SPAWNING; // Change the state to spawning
                }
                return -1; // Placeholder for enemy spawning logic
                
            case NO_ENEMY_LEFT:
                return -2; // Placeholder for enemy spawning logic
                
            default:
                return -1;
        }
    }

    // Getters and Setters
    public int getCurrentWaveIndex() {
        return currentWaveIndex; // Get the current wave index
    }
    public int getCurrentGroupIndex() {
        return currentGroupIndex; // Get the current group index
    }
}
package com.kurabiye.kutd.model.Managers;

import java.util.ArrayList;
import java.util.Iterator;

import com.kurabiye.kutd.model.Coordinates.TilePoint2D;
import com.kurabiye.kutd.model.Coordinates.Point2D;
import com.kurabiye.kutd.model.Enemy.Enemy;
import com.kurabiye.kutd.model.Enemy.EnemyFactory;
import com.kurabiye.kutd.model.Enemy.IEnemy;
import com.kurabiye.kutd.model.Enemy.Decorators.SynergeticMoveDecorator;
import com.kurabiye.kutd.model.Enemy.EnemyType;
import com.kurabiye.kutd.model.Listeners.IGameUpdateListener;
import com.kurabiye.kutd.model.Map.GameMap;
import com.kurabiye.kutd.model.Player.Player;
import com.kurabiye.kutd.model.Player.UserPreference;
import com.kurabiye.kutd.model.Projectile.Projectile;
import com.kurabiye.kutd.model.Projectile.IProjectile;
import com.kurabiye.kutd.model.Projectile.DamageType;
import com.kurabiye.kutd.model.Projectile.ProjectileState;
import com.kurabiye.kutd.model.Tile.Tile;
import com.kurabiye.kutd.model.Tile.TileFactory;
import com.kurabiye.kutd.model.Timer.GameTimer;
import com.kurabiye.kutd.model.Tower.Tower;
import com.kurabiye.kutd.model.Tower.ITower;
import com.kurabiye.kutd.model.Tower.TowerFactory;
import com.kurabiye.kutd.model.Tower.TowerFactory.TowerType;

/* GameManager.java
 * This class is responsible for managing the game state, including
 * the game loop, player input, and game events. It will also handle
 * the interactions between different game components, such as enemies,
 * towers, and the game map.
 * 
 * 
 * 
 * @author: Atlas Berk Polat
 * @version: 1.0
 * @since: 2025-04-28
 */

public class GameManager implements Runnable{

    private static final int TILE_SIZE = 120; // Size of a tile in pixels


    private static final int TARGET_FPS = 60; // Target frames per second

    private WaveManager waveManager; // Wave manager for handling enemy waves
    
    // Thread management
    private Thread gameThread; // Reference to the game thread
    private volatile boolean running = true; // Flag to control thread execution


    // Add a flag to control test enemy spawning


    public enum GameState {
        INITIALIZING,
        RUNNING,
        PAUSED,
        GAME_LOST,
        GAME_WON,
    }

    private volatile GameState gameState; // Current state of the game

    private GameTimer gameTimer; // Game time

    private GameMap gameMap; // Game map

    private Player player; // Player object

    private UserPreference userPreferences; // User preferences object


    private TowerFactory towerFactory; // Tower factory for creating towers

    private EnemyFactory enemyFactory; // Enemy factory for creating enemies


    private ArrayList<Point2D> path; // Path for enemies to follow

    private ArrayList<ITower> towers; // List of towers in the game
    private ArrayList<IEnemy> enemies; // List of enemies in the game
    private ArrayList<IProjectile> projectiles; // List of projectiles in the game

    


    // Tile Factory to build new Towers
    private TileFactory tileFactory; // Tile factory for creating tiles


    // The callback for the view update method
    
    private IGameUpdateListener gameUpdateListener; // Listener for game updates

    private ArrayList<IEnemy> synergeticEnemies;
    private ArrayList<IEnemy> enemiesToAdd = new ArrayList<>(); // List of synergetic enemies to remove
    private ArrayList<IEnemy> enemiesToRemove = new ArrayList<>(); // List of enemies to remove
    private ArrayList<IProjectile> projectilesToRemove = new ArrayList<>(); // List of projectiles to remove


    public GameManager(GameMap gameMap) {
        this.gameState = GameState.INITIALIZING; // Initialize game state to RUNNING
        this.gameTimer = GameTimer.getInstance(); // Get the singleton instance of GameTimer
        this.gameTimer.setTimeCoefficient(1); // Set the time coefficient to 1 (normal speed)
        this.gameMap = gameMap; // Initialize the game map
        this.userPreferences = UserPreference.getInstance(); // Initialize user preferences
        this.player = new Player(userPreferences); // Initialize the player object

        path = (ArrayList<Point2D>) gameMap.getPointPath(); // Get the path from the game map

        this.waveManager = new WaveManager(this.userPreferences); // Initialize the wave manager
        this.towerFactory = TowerFactory.getInstance(); // Initialize the tower factory

        this.enemyFactory = EnemyFactory.getInstance(); // Initialize the enemy factory
        this.enemyFactory.setEnemyPath(path); // Set the enemy path in the factory
        
        this.towers = new ArrayList<>(); // Initialize the list of towers
        this.enemies = new ArrayList<>(); // Initialize the list of enemies
        this.projectiles = new ArrayList<>(); // Initialize the list of projectiles

        this.synergeticEnemies = new ArrayList<>(); // Initialize the list of synergetic enemies

        this.tileFactory = new TileFactory(); // Initialize the tile factory
    }

    public void setGameUpdateListener(IGameUpdateListener gameUpdateListener) {
        this.gameUpdateListener = gameUpdateListener; // Set the game update listener
    }

    @Override
    public void run() {
        // Game loop
        while (running && gameState != GameState.GAME_LOST && gameState != GameState.GAME_WON) {

            gameTimer.resetTimer();
            while (running && gameState != GameState.PAUSED) {
                
            // Check if thread has been requested to stop
            if (!running) {
                break;
            }
            
            // Update game state
            if (gameState == GameState.PAUSED) {
                // Pause game logic
                try {
                    Thread.sleep(100); // Sleep for a short duration to avoid busy waiting
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                continue; // Skip the rest of the loop if the game is paused
            }

            // Calculate the delta time
            gameTimer.update(); // Update the game timer
            double deltaTime = gameTimer.getDeltaTime(); // Get the delta time from the game timer

            // Create new enemies
            // Using our test enemy code
            int enemyIndex = waveManager.getEnemy(deltaTime); // Get the index of the enemy to spawn
           
            if (enemyIndex > -1) {
                Enemy enemy = enemyFactory.createEnemy(enemyIndex); // Create a new enemy using the factory
                enemies.add(enemy); // Add the enemy to the list of enemies
            } else if (enemyIndex == -2 && enemies.size() == 0) {
                // No enemies left to spawn
                gameState = GameState.GAME_WON; // Set game state to GAME_WON
            }

            


         


            // Update enemies position
            Iterator<IEnemy> enemyIterator = enemies.iterator(); // Create an iterator for the list of enemies

            while (enemyIterator.hasNext()) {
                IEnemy enemy = enemyIterator.next(); // Get the next enemy
               
                enemy.move(deltaTime); // Update the enemy's position
                
                if (enemy.hasArrived()) {
                    enemyIterator.remove(); // Remove the enemy from the list if it is out of bounds
                    player.loseHealth(); // Deduct health from the player
                }
            }

            // Towers look for targets and create projectiles
            for (ITower tower : towers) {
                // Check if the tower can attack     
                // Get the projectile from the tower
                Projectile projectile = tower.attack(enemies, deltaTime); // Attack enemies and get the projectile
                if (projectile != null) {
                    projectiles.add(projectile); // Add the projectile to the list of projectiles
                }
            }

            // Update projectiles position
            for (IProjectile projectile : projectiles) {
                
                projectile.move(deltaTime); // Update each projectile's position
            }

            // Check for collisions between projectiles and enemies
            // Keep track of projectiles that need to be removed
            // Keep track of the enemies that are dead and need to be removed
            
            projectilesToRemove.clear(); // Clear the list of projectiles to remove
            enemiesToRemove.clear(); // Clear the list of enemies to remove

            for (IProjectile projectile : projectiles) {
                // Check if any collision occurred

                if (projectile.getProjectileState() == ProjectileState.DEAD) {
                    projectilesToRemove.add(projectile); // Skip if the projectile is stopped
                }

                if (projectile.getProjectileState() == ProjectileState.STOPPED) {
                    continue; // Skip if the projectile is stopped
                }

                if (projectile.getProjectileState() == ProjectileState.MOVING) {
                    continue; // Skip if the projectile is dead
                }

                if (projectile.getDamageType() == DamageType.AREA) {
                    continue; // Skip if the projectile is an area explosion
                    
                }

                boolean collisionOccurred = false; // Flag to check if a collision occurred

                for (IEnemy enemy : enemies) {
                    double distance = projectile.getCoordinate().distance(enemy.getCoordinate());
                    float damageRadius = projectile.getProjectileAreaDamage();

                    double distanceToTarget = projectile.getCoordinate().distance(projectile.getTarget());
                    
                    if (distance < damageRadius) { // Check for collision
                       
                        
                        enemy.getDamage(projectile.getProjectileType()); // Apply damage to the enemy
                        
                        if (enemy.isDead()) {
                            int reward = enemy.getKillReward();
                            player.earnGold(reward); // Add gold to the player for killing the enemy
                            enemiesToRemove.add(enemy); // Mark the enemy for removal
                        }
                        collisionOccurred = true; // Set the collision flag to true
                        
                        if(projectile.getProjectileAreaDamage() <= 1f){
                            projectilesToRemove.add(projectile); // Mark the projectile for removal
                            break; // Exit the loop if a collision occurred
                        }
                    }else if(distanceToTarget < deltaTime * projectile.getSpeedVector().magnitude()){
                        // Check if the projectile has reached its target


                             enemy.getDamage(projectile.getProjectileType()); // Apply damage to the enemy
                        
                            if (enemy.isDead()) {
                            int reward = enemy.getKillReward();
                            player.earnGold(reward); // Add gold to the player for killing the enemy
                            enemiesToRemove.add(enemy); // Mark the enemy for removal
                            }
                            collisionOccurred = true; // Set the collision flag to true
                        
                            projectilesToRemove.add(projectile); // Mark the projectile for removal
                            
                        

                    }
                }

                if(collisionOccurred) {
                    // Remove the projectile if it has collided with an enemy
                    projectilesToRemove.add(projectile); // Mark the projectile for removal
                }
            }


            // Check the explosion type of projectiles

            for (IProjectile projectile : projectiles) {
                if (projectile.getDamageType() == DamageType.AREA) {
                    // check if the projectile is close enough to the its target
                    double distance = projectile.getCoordinate().distance(projectile.getTarget());

                    if (distance < deltaTime * projectile.getSpeedVector().magnitude()) {
                        // Apply area damage to all enemies within the explosion radius
                        for (IEnemy enemy : enemies) {
                            double distanceToEnemy = projectile.getCoordinate().distance(enemy.getCoordinate());
                            if (distanceToEnemy < projectile.getProjectileAreaDamage()) {
                                enemy.getDamage(projectile.getProjectileType()); // Apply damage to the enemy
                                if (enemy.isDead()) {
                                    int reward = enemy.getKillReward();
                                    player.earnGold(reward); // Add gold to the player for killing the enemy
                                    enemiesToRemove.add(enemy); // Mark the enemy for removal
                                }
                            }
                        }
                        projectilesToRemove.add(projectile); // Mark the projectile for removal
                    }

                }
            }


            /*
             * Checking if there is any knight within a tile distance to a goblin
             * If there is, the knight will be decorated SynergeticMoveDecorator
             * This will allow the knight to move faster when near a goblin
             * This is a synergetic movement behavior
             * 
             */

            // Check for synergetic movement behavior




            for (IEnemy knight : enemies) {
                if (knight.getEnemyType() == EnemyType.KNIGHT) { // Check if the enemy is a knight
                    for (IEnemy goblin : enemies) {
                        if (goblin.getEnemyType() == EnemyType.GOBLIN) { // Check if the enemy is a knight
                            double distance = knight.getCoordinate().distance(goblin.getCoordinate()); // Calculate distance between knight and goblin
                            if (distance < TILE_SIZE) { // If the distance is less than 2 tiles
                                 enemiesToRemove.add(knight); // Mark the knight for removal
                                // Create a new synergetic enemy with the knight's properties

                                int[] enemySpeeds = UserPreference.getInstance().getEnemyMovementSpeed();

                                IEnemy synergeticKnight = new SynergeticMoveDecorator(knight, enemySpeeds[0] , enemySpeeds[1]); // Create a new synergetic knight with the knight's properties

                                synergeticEnemies.add(synergeticKnight); // Add the synergetic knight to the list of synergetic enemies
                                enemiesToAdd.add(synergeticKnight); // Add the synergetic knight to the list of enemies to add
                            }
                        }else{
                            // then remove the decorated knight from the synergetic enemies list
                            // if the knight is decorated, remove the decoration

                            if (synergeticEnemies.contains(knight)) {
                                synergeticEnemies.remove(knight); // Remove the knight from the synergetic enemies list
                                // remove the decorated knight from the enemies list
                                enemiesToRemove.add(knight); // Mark the knight for removal
                                knight = ((SynergeticMoveDecorator) knight).removeDecoration(); // Remove the decoration from the knight
                                enemiesToAdd.add(knight); // Add the knight to the list of enemies to add
                            }
                        }
                    }
                }
            }

            // Remove dead enemies from the list
            enemies.removeAll(enemiesToRemove); // Remove the marked enemies from the list
            // Remove projectiles that have collided with enemies
            projectiles.removeAll(projectilesToRemove); // Remove the marked projectiles from the list

            

            // Check if the game is over
            if (player.getCurrentHealth() <= 0) {
                gameState = GameState.GAME_LOST; // Set game state to GAME_LOST
            }

            if (gameUpdateListener != null) {
                gameUpdateListener.onGameUpdate(deltaTime); // Call the update method on the listener
            }
             
           
            // Sleep for a short duration to control the frame rate
            try {
                Thread.sleep((long)((1000/TARGET_FPS)/ gameTimer.getTimeCoefficient())); // Approximately 60 FPS
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

         }
        }
    }

    public GameMap getGameMap() {
        return gameMap; // Get the game map
    }

    // Controller methods
    public void pauseGame() {
        gameState = GameState.PAUSED;
        // Pause game logic
    }
    
    public void resumeGame() {
        gameState = GameState.RUNNING;
        // Resume game logic
    }
    
    public void endGame() {
        gameState = GameState.GAME_LOST;
        running = false; // Stop the game loop
        // Handle game over logic
    }

    public GameState getGameState() {
        return gameState;
    }

    public void returnToMainMenu() {
        gameState = GameState.INITIALIZING;
        running = false; // Stop the game loop
        // Handle return to main menu logic
        
    }

    public void speedUpGame() {
        // Increase game speed
        gameTimer.setTimeCoefficient(2.0);
    }
    
    public void slowDownGame() {
        // Decrease game speed
        gameTimer.setTimeCoefficient(1);
    }

    public boolean buildTower(int xCoordinate, int yCoordinate, int towerType) {
        //check if the tile is buildable
        Tile tile = gameMap.getTile(xCoordinate, yCoordinate);
        if (tile == null) {
            return false; // Invalid tile coordinates
        }
        if (!tile.isBuildableTile()) {
            return false; // Tile is not buildable
        }

        // Check if the player has enough resources
        if(player.getCurrentGold() < userPreferences.getTowerConstructionCost()[0][towerType]) { // Example cost check
            return false; // Not enough gold
        }

        player.buyTower(userPreferences.getTowerConstructionCost()[0][towerType]); // Deduct cost from player's gold
        // Create the tower using the TowerFactory

        Tower tower = towerFactory.create(TowerType.values()[towerType]); // Create the tower using the factory
        // Set the tower's coordinates
        tower.setTileCoordinate(new TilePoint2D(xCoordinate, yCoordinate));
        // Add the tower to the list of towers
        towers.add(tower);

        int tileCode;

        if (towerType == 0) {
            tileCode = 20; // Example tile code for tower type 0
        } else if (towerType == 1) {
            tileCode = 21; // Example tile code for tower type 1
        } else if (towerType == 2) {
            tileCode = 26; // Example tile code for tower type 2
        } else {
            return false; // Invalid tower type
        }

        Tile towerTile = tileFactory.create(tileCode); // Create the tower tile using the factory
        gameMap.setTile(xCoordinate, yCoordinate, towerTile);

        return true;
    }
    
    public boolean sellTower(int xCoordinate, int yCoordinate, int towerType) {
        // Logic to sell a tower
        // Check if the tower exists at the given coordinates

        // look for a tower in the list of towers
        for (ITower tower : towers) {
            if (tower.getTileCoordinate().getTileX() == xCoordinate && tower.getTileCoordinate().getTileY() == yCoordinate) {
                // Tower found, sell it
                player.sellTower(tower.getSellReturn()); // Add sell return to player's gold
                towers.remove(tower); // Remove the tower from the list
                Tile buildableTile = this.tileFactory.create(15); // Create a buildable tile using the factory
                gameMap.setTile(xCoordinate, yCoordinate, buildableTile);
                return true; // Tower sold successfully
            }
        }
        return false; // Tower not found at the given coordinates
    }

    public void startGame() {
        // Create a new thread using this instance (which implements Runnable)
        gameThread = new Thread(this);
        // Start the thread, which will call the run() method

        gameState = GameState.RUNNING; // Set the game state to RUNNING
        gameTimer.resetTimer();
        
        gameThread.start();
    }

    public void killGameThread() {
        if (gameThread != null && gameThread.isAlive()) {
            running = false; // Signal the thread to stop
            gameState = GameState.GAME_LOST; // Force game state to end
            
            try {
                // Wait for the thread to die, but with a timeout
                gameThread.join(1000);
                
                // If the thread is still alive after timeout, interrupt it
                if (gameThread.isAlive()) {
                    gameThread.interrupt();
                    gameThread.join(1000); // Give it a second chance to terminate
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        
        // Clear game resources
        enemies.clear();
        projectiles.clear();
        
        // Reset the game timer
        gameTimer.resetTimer();
    }

    // Info provider methods for the view


    public ArrayList<ITower> getTowers() {
        return towers; // Return the list of towers
    }

    public ArrayList<IEnemy> getEnemies() {
        return enemies; // Return the list of enemies
    }

    public ArrayList<IProjectile> getProjectiles() {
        return projectiles; // Return the list of projectiles
    }

    public Player getPlayer() {
        return player; // Return the player object
    }

    public GameTimer getGameTimer() {
        return gameTimer; // Return the game timer
    }

    public UserPreference getUserPreferences() {
        return userPreferences; // Return the user preferences
    }

    public int getCurrentWaveIndex() {
        return waveManager.getCurrentWaveIndex(); // Return the current wave index
    }

    public int getCurrentGroupIndex() {
        return waveManager.getCurrentGroupIndex(); // Return the current group index
    }

    public ArrayList<IEnemy> getEnemiesToRemove() {
        return enemiesToRemove; // Return the list of enemies to remove
    }
    public ArrayList<IProjectile> getProjectilesToRemove() {
        return projectilesToRemove; // Return the list of projectiles to remove
    }

}
package com.kurabiye.kutd.model.Timer;

/* GameTimer.java
 * This class is responsible for managing the game timer.
 * It is used to keep track of the time elapsed during the game.
 * It can be used to get the delta time between frames and to manage the game loop.
 * It is a singleton class, meaning that there is only one instance of this class in the game.
 * 
 * @author Atlas Berk Polat
 * @version 1.0
 * @since 2025-04-25
 * 
 */

public class GameTimer {


    
    private static final double TIME_COFACTOR_MILISEC = 1000; // The time cofactor used to convert seconds to milliseconds

    private double timeCoefficient = 1; // The time coefficient used to adjust the game speed

    // Using volatile to ensure visibility across threads
    private static volatile GameTimer instance; // Singleton instance of the GameTimer class

    private double lastTime; // The last time the game timer was updated
    private double deltaTime; // The time elapsed since the last update

    private GameTimer() {
        lastTime = System.currentTimeMillis(); // Initialize the last time to the current time
    }

    /**
     * Thread-safe singleton implementation using double-checked locking
     * @return The singleton instance of GameTimer
     */
    public static GameTimer getInstance() {
        // First check (no locking)
        if (instance == null) {
            // Lock for thread safety
            synchronized (GameTimer.class) {
                // Second check (with locking)
                if (instance == null) {
                    instance = new GameTimer(); // Create a new instance if it doesn't exist
                }
            }
        }
        return instance; // Return the singleton instance
    }

    /**
     * Resets the singleton instance (useful for testing)
     */
    public static synchronized void resetInstance() {
        instance = null;
    }

    /*
     * This should be called every frame to update the game timer.
     * It calculates the delta time and updates the last time.
     * 
     */
    public synchronized void update() {
        long currentTime = System.currentTimeMillis(); // Get the current time
        deltaTime = currentTime - lastTime; // Calculate the delta time
        lastTime = currentTime; // Update the last time to the current time
    }

    public synchronized void resetTimer() {
        lastTime = System.currentTimeMillis(); // Reset the last time to the current time
    }


    /**
     * This method returns the delta time in seconds.
     * It divides the delta time by the time cofactor to convert it to seconds.
     * @return the delta time in seconds
     */
    public synchronized double getDeltaTime() {
        return (deltaTime / TIME_COFACTOR_MILISEC) * timeCoefficient; // Return the delta time
    }

    /**
     * Get the time coefficient used to adjust game speed
     * @return the time coefficient value
     */
    public synchronized double getTimeCoefficient() {
        return timeCoefficient; // Return the time coefficient
    }
    
    /**
     * Set the time coefficient to adjust game speed
     * @param coefficient the new time coefficient
     */
    public synchronized void setTimeCoefficient(double coefficient) {
        if (coefficient > 0) {
            timeCoefficient = coefficient;
        }
    }
}
package com.kurabiye.kutd.model.Tile;

import com.kurabiye.kutd.model.Coordinates.TilePoint2D;

/* Tile.java
 * This class represents a tile in the game.
 * It is an abstract class that can be extended by other classes to define specific types of tiles.
 * 
 * 
 * @author Atlas Berk Polat
 * @version 1.0
 * @since 2025-04-23
 */

public class Tile {
        


        /* Tile code is very important for the view layer.
         * It is used to determine which tile to draw on the screen.
         * We will decide the specific tile code for each tile type later.
         * The Map class will use this code to draw the tile on the screen.
         * 
         */
        private int tileCode; // Code for the tile

        /* The tileDirections array is used to store the directions of the tile.
         *         1
         *    0 - Tile - 2
         *         3
         */
        private int tileDirections[];
        

        private TilePoint2D coordinate; // Coordinate of the tile on the map

        /* The neighbors array is used to store the neighboring tiles of this tile.
         * There is a maximum of 8 neighbors for each tile.
         * And there is a minimum of 3 neighbors for each tile.
         * Here is the coding for the neighbors array:
         *      0 1 2
         *      7 X 3
         *      6 5 4 
         */

        public Tile(int tileCode) {
            this.tileCode = tileCode; // Set the tile code


            
        }

        private boolean isPathTile = false; // Walkable status of the tile
        private boolean isBuildableTile = false; // Buildable status of the tile
        private boolean isTowerTile = false; // Tower status of the tile
        private boolean isGroundTile = false; // Ground status of the tile
        private boolean isDecorationTile = false; // Decoration status of the tile


        public int getTileCode() {
            return tileCode; // Get the code of the tile
        }

        public boolean isPathTile() {
            return isPathTile; // Check if the tile is a path tile
        }
        public boolean isBuildableTile() {
            return isBuildableTile; // Check if the tile is buildable
        }
        public boolean isGroundTile() {
            return isGroundTile; // Check if the tile is a ground tile
        }
        public boolean isDecorationTile() {
            return isDecorationTile; // Check if the tile is a decoration tile
        }

        public boolean isTowerTile() {
            return isTowerTile; // Check if the tile is a tower tile
        }


        public void setTileCode(int tileCode) {
            this.tileCode = tileCode; // Set the code of the tile
        }
        public void setPathTile(boolean isPathTile) {
            this.isPathTile = isPathTile; // Set the tile as a path tile
        }
        public void setBuildableTile(boolean isBuildableTile) {
            this.isBuildableTile = isBuildableTile; // Set the tile as buildable
        }
        public void setGroundTile(boolean isGroundTile) {
            this.isGroundTile = isGroundTile; // Set the tile as a ground tile
        }
        public void setDecorationTile(boolean isDecorationTile) {
            this.isDecorationTile = isDecorationTile; // Set the tile as a decoration tile
        }
        public void setTowerTile(boolean isTowerTile) {
            this.isTowerTile = isTowerTile; // Set the tile as a tower tile
        }

        public void setCoordinate(TilePoint2D coordinate) {
            this.coordinate = coordinate; // Set the coordinate of the tile
        }




        public TilePoint2D getCoordinate() {
            return coordinate; // Get the coordinate of the tile
        }


        public int[] getTileDirections() {
            return tileDirections; // Get the directions of the tile
        }
        public void setTileDirections(int[] tileDirections) {
            this.tileDirections = tileDirections; // Set the directions of the tile
        }



        

}
package com.kurabiye.kutd.model.Tile;

import com.kurabiye.kutd.util.FactoryPattern.CodeFactory;

/* TileFactory.java
 * This class is responsible for creating tile objects.
 * It is a factory class that can be used to create different types of tiles.
 * 
 */

public class TileFactory implements CodeFactory<Tile> {
    // This method creates a tile object based on the given code.

    /*
     *  if(isIn(tileCode, new int[]{0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14})) {
                isPathTile = true; // Set the tile as a path tile
            }

            if(tileCode == 15) {
                isBuildableTile = true; // Set the tile as buildable
            }

            if(tileCode == 5) {
                isGroundTile = true; // Set the tile as a starting tile
            }

            if(isIn(tileCode, new int[]{20, 21, 26})){
                isTowerTile = true; // Set the tile as a tower tile
            }

            if(isIn(tileCode, new int[]{16, 17, 18, 19, 22, 23, 24, 25, 27, 28, 29, 30, 31})) {
                isDecorationTile = true; // Set the tile as a starting tile
            }
     * 
     * 
     */
    @Override
    public Tile create(int code) {

        // check if the code is within the range

        if(code < 0 || code > 31) {
            throw new IllegalArgumentException("Invalid tile code: " + code);
        }

        Tile tile = new Tile(code);

        if(isIn(code, new int[]{0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14})) {
            tile.setPathTile(true);

            /*
             * Set up the tile directions
             *         1
             *    0 - Tile - 2
             *         3
             */

             int dir1 = -1;
             int dir2 = -1;
            
            // 0
            if (isIn(code, new int[]{1, 2, 9, 10, 13, 14})) {
                dir1 = 0; // Set direction 1 to 0
                
            }
            // 1
            if (isIn(code, new int[]{4, 6, 7, 8, 10, 11})) {
                if (dir1 == -1) {
                    dir1 = 1; // Set direction 1 to 1            
                }else {
                    dir2 = 1; // Set direction 2 to 1
                }
            }

            // 2

            if (isIn(code, new int[]{0, 1, 8, 9, 12, 13})) {
                if (dir1 == -1) {
                    dir1 = 2; // Set direction 1 to 2
                }else {
                    dir2 = 2; // Set direction 2 to 2
                }
            }

            // 3

            if (isIn(code, new int[]{0, 2, 3, 4, 6, 7})) {
                if (dir1 == -1) {
                    dir1 = 3; // Set direction 1 to 3
                }else {
                    dir2 = 3; // Set direction 2 to 3
                }
            }


            int[] tileDirections = new int[]{dir1, dir2};

            tile.setTileDirections(tileDirections);
        }

        if(code == 15) {
            tile.setBuildableTile(true);
        }

        if(code == 5) {
            tile.setGroundTile(true);
        }

        if(isIn(code, new int[]{20, 21, 26})){
            tile.setTowerTile(true);
        }

        if(isIn(code, new int[]{16, 17, 18, 19, 22, 23, 24, 25, 27, 28, 29, 30, 31})) {
            tile.setDecorationTile(true);
        }


        return tile;
    }


    // Helper method

    private static boolean isIn(int num, int[] arr){

        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == num) {
                return true; // Return true if the number is found in the array
            }
        }
        return false; // Return false if the number is not found in the array
    }

    



}
package com.kurabiye.kutd.model.Projectile;

public enum ProjectileState { // Enum for projectile states
        MOVING, // Projectile is alive
        ACTIVE, // Projectile is active
        STOPPED, // Projectile is dead
        DEAD
    }package com.kurabiye.kutd.model.Projectile;

import com.kurabiye.kutd.model.Coordinates.Point2D;
import com.kurabiye.kutd.model.Projectile.ProjectileMoveStrategy.IProjectileMoveStrategy;

/* Projectile.java
 * This class represents a projectile in the game.
 * It handles the projectile's movement, state, and damage.
 * 
 * @author Atlas Berk Polat
 * @version 2
 * @since 2025-05-13
 * 
 */

public class Projectile implements IProjectile {

    public enum ProjectileType { // Enum for different projectile types
        ARROW(0), // Arrow projectile type
        MAGIC(1), // Magic projectile type
        ARTILLERY(2); // Artillery projectile type

        private final int value;

        ProjectileType(int value) {
            this.value = value;
        }
        
        public int getValue() {
            return value;
        }
    }


    //private final static double EPSILON = 1; // Epsilon value for floating point comparison


    private ProjectileType projectileType; // Type of the projectile

    //private Point2D startCoordinate; // Starting coordinate of the projectile on the map

    private Point2D targetCoordinate; // Ending coordinate of the projectile on the map

    private float gravityFactor; // Gravity factor for the projectile's trajectory

    private Point2D coordinate; // Coordinate of the projectile on the map

    private Point2D speedVector;

    private float projectileAreaDamage = 30f; // Area damage of the projectile

    private float speed; // Speed of the projectile


    private double projectileLifeTime = 3f; // Life time of the projectile

    private double projectileLifeTimeCounter = 0; // Counter for the projectile's life time

    private double projectileExplosiveActtionTime = 0.1f; // Time to explode after reaching the target


    private ProjectileState projectileState = ProjectileState.MOVING; // Projectile's alive status


    private DamageType damageType = DamageType.TARGET; // Type of explosion


    // Phase 2:

    private int projectileLevel = 1; // Level of the projectile




    public Projectile(ProjectileType projectileType, Point2D startCoordinate, Point2D targetCoordinate, IProjectileMoveStrategy moveStrategy, float projectileAreaDamage, DamageType damageType) {
        this.damageType = damageType; // Set the explosion type
        this.projectileType = projectileType;
        //this.startCoordinate = startCoordinate;
        this.targetCoordinate = targetCoordinate;
        this.gravityFactor = moveStrategy.getGravityFactor(); // Get the gravity factor from the move strategy
        this.speed = moveStrategy.getSpeed(); // Get the speed from the move strategy
        
        this.projectileAreaDamage = projectileAreaDamage; // Set the area damage of the projectile

        Point2D[] dataArray = moveStrategy.getSpeedVector(startCoordinate, targetCoordinate, gravityFactor); // Get the speed vector and life time from the move strategy
        this.speedVector = dataArray[0].multiply(this.speed); // Calculate the speed vector using the provided move strategy and then multiply it by the speed of the projectile



        this.projectileLifeTime = dataArray[1].getX(); // Get the life time of the projectile from the move strategy

        this.projectileExplosiveActtionTime = dataArray[1].getY(); // Get the explosive action time of the projectile from the move strategy


        this.coordinate = startCoordinate; // Set the starting coordinate of the projectile
   
   
    }

    
    public DamageType getDamageType() {
        return damageType; // Get the explosion type
    }

    public Point2D getTarget(){
        return targetCoordinate; // Get the target coordinate of the projectile
    }
  


    public ProjectileType getProjectileType() {
        return projectileType;
    }

    public float getProjectileAreaDamage() {
        return projectileAreaDamage; // Get the area damage of the projectile
    }


    //private static final double EPSILON = 1e-1; // Epsilon value for floating point comparison

    private double expirationTime = 0;

    public synchronized void move(double deltaTime) {
        if (projectileState == ProjectileState.MOVING || projectileState == ProjectileState.ACTIVE) {

            speedVector = speedVector.add(0, 1 * gravityFactor * deltaTime); // Update the speed vector with the gravity factor and delta time

            // Check if the speed vector is zero
            if (speedVector.magnitude() == 0) {
                return;
            }

            // Update the projectile's coordinate based on the speed vector and delta time
            coordinate = coordinate.add(speedVector.multiply(deltaTime)); // Update the coordinate of the projectile based on the speed vector and delta time

            // Check if the projectile has reached its target coordinate
            if (coordinate.distance(targetCoordinate) < deltaTime * speed) {
                coordinate = targetCoordinate; // Set the coordinate to the target coordinate
                projectileState = ProjectileState.STOPPED; // Stop the projectile if it has reached the target
            }

            // Check if the projectile has reached its explosive action time

            if (projectileLifeTimeCounter > projectileExplosiveActtionTime) {
                projectileState = ProjectileState.ACTIVE; // Set the projectile state to ACTIVE if it has reached its explosive action time
            }


            // Check if the projectile has exceeded its life time
            if (projectileLifeTimeCounter > projectileLifeTime) {
                projectileState = ProjectileState.STOPPED; // Set the projectile state to DEAD if it has exceeded its life time
            } else {
                projectileLifeTimeCounter += deltaTime; // Increment the life time counter
            }


            
           
        
        }else if (projectileState == ProjectileState.STOPPED) {
            expirationTime += deltaTime; // Update the expiration time of the projectile
            if (expirationTime > 5f) {
                projectileState = ProjectileState.DEAD; // Set the projectile state to DEAD after a certain time
            }
        }
    }

    public Point2D getCoordinate() {
        return coordinate; // Get the current coordinate of the projectile
    }

    // Get the projectile's speed vector
    public Point2D getSpeedVector() {
        return speedVector; // Get the speed vector of the projectile
    }

    public ProjectileState getProjectileState() {
        return projectileState; // Get the projectile's alive status
    }


    public void setProjectileLevel(int level) {
        this.projectileLevel = level; // Set the projectile's level
    }
    public int getProjectileLevel() {
        return projectileLevel; // Get the projectile's level
    }

}
package com.kurabiye.kutd.model.Projectile.ProjectileMoveStrategy;

import com.kurabiye.kutd.model.Coordinates.Point2D;

public interface IProjectileMoveStrategy {
    /*
     * The first Point2D in the array is the speed vector of the projectile
     * The second Point2D.x in the array is the gravity factor of the projectile
     * The second Point2D.y the array is the speed of the projectile
     */
    Point2D[] getSpeedVector(Point2D startingPoint, Point2D targetPoint, float gravity); // Method to calculate the angle of the projectile's trajectory
    float getGravityFactor(); // Method to get the gravity factor of the projectile's trajectory
    float getSpeed(); // Method to get the speed of the projectile's trajectory at the rooute

  
}
package com.kurabiye.kutd.model.Projectile.ProjectileMoveStrategy;

import com.kurabiye.kutd.model.Coordinates.Point2D;

public class MagicProjectileMoveStrategy implements IProjectileMoveStrategy {

    public static final float speed = 600.0f; // Speed of the projectile


    private static final double PROJECTILE_LIFE_TIME = 5f; // Life time of the projectile


/* 
    @Override
    public Point2D[] getSpeedVector(Point2D startingPoint, Point2D targetPoint, float gravity) {
        
        Point2D speedVector = targetPoint.subtract(startingPoint); // Calculate the speed vector from the starting point to the target point
        
        double length = speedVector.magnitude(); // Get the length of the speed vector

        if (length > 0) {
            speedVector = speedVector.normalize(); // Normalize the speed vector to get the direction
        } else {
            return new Point2D[]{new Point2D(0, 0), new Point2D(PROJECTILE_LIFE_TIME, 0.1)}; // If the length is zero, return a zero vector
        }

        return new Point2D[]{speedVector, new Point2D(length, gravity)}; // Return the normalized speed vector
    }
*/


    @Override
    public Point2D[] getSpeedVector(Point2D startingPoint, Point2D targetPoint, float gravity) {
        // Calculate the speed vector from the starting point to the target point
        Point2D speedVector = targetPoint.subtract(startingPoint);
        
        // Get the length of the speed vector
        double length = speedVector.magnitude();

        if (length > 0) {
            // Normalize the speed vector to get the direction
            speedVector = speedVector.normalize();
        } else {
            return new Point2D[]{new Point2D(0, 0), new Point2D(PROJECTILE_LIFE_TIME, 0.1)}; // If the length is zero, return a zero vector
        }

        return new Point2D[]{speedVector, new Point2D(length/speed, gravity)}; // Return the normalized speed vector
    }

    @Override
    public float getGravityFactor() {
        return 0; // Straight line movement does not consider gravity, so return 0
    }

    @Override
    public float getSpeed() {
        return speed; // Return the speed of the projectile
    }




  


}
package com.kurabiye.kutd.model.Projectile.ProjectileMoveStrategy;

import com.kurabiye.kutd.model.Coordinates.Point2D;

public class ArtilleryProjectileMoveStrategy implements IProjectileMoveStrategy {

    private static final float GRAVITY = 0; // Gravity constant
    private float ARTILLERY_SPEED = 50; // Speed of the artillery projectile
    
/*
    @Override
    public Point2D[] getSpeedVector(Point2D startingPoint, Point2D targetPoint, float gravity) {

        //return new Point2D[]{new Point2D(0, 1), new Point2D(10f, 9)}; // Return a zero vector if the length is zero

        // Use the class constant instead of the parameter
        gravity = GRAVITY;

        // Calculate the distance between the starting point and target point
        double dx = targetPoint.getX() - startingPoint.getX(); // Horizontal distance
        double dy = (startingPoint.getY() - targetPoint.getY()); // Vertical distance (positive when target is below)
        
      // Angle = 45 degrees

        double angle = Math.atan(2); // 45 degrees in radians


       


        double velocityTimesTime = dx/Math.cos(angle); // Horizontal component of velocity times time

        double timeSquared = (velocityTimesTime * Math.sin(angle) - dy) / gravity; // Time squared

        if (dy > 0) { // If the target is above the starting point
            timeSquared = (velocityTimesTime * Math.sin(angle) + dy) / gravity; // Time squared
        }


        

        double timeOfFlight = 2 * Math.sqrt(Math.abs(timeSquared)); // Time of flight

        double initialVelocity = Math.abs(dx/( timeOfFlight * Math.cos(angle))); // Initial velocity

        ARTILLERY_SPEED = (float) initialVelocity; // Set the speed of the artillery projectile


        // Turn to right or left

        double turnCofficient = 1;

        if (dx < 0) { // If the target is to the left of the starting point
            turnCofficient = -1; // Set the turn coefficient to -1
        } 

        double initialSpeedX = turnCofficient * initialVelocity * Math.cos(angle); // Initial speed in x direction
        double initialSpeedY = -1 * initialVelocity * Math.sin(angle); // Initial speed in y direction

        // Create the speed vector
        Point2D initialSpeedVector = new Point2D(initialSpeedX, initialSpeedY); // Speed vector
        // Calculate the activation time

        // Normalize the speed vector
        double length = initialSpeedVector.magnitude(); // Get the length of the speed vector

        if (length > 0) {
            initialSpeedVector = initialSpeedVector.normalize(); // Normalize the speed vector to get the direction
        } else {
            return new Point2D[]{new Point2D(0, 0), new Point2D(0.1f, 0)}; // If the length is zero, return a zero vector
        }

        // Calculate the activation time

        double activationTime = timeOfFlight - 0.1; // Activation time (0.1 seconds before the projectile reaches the target)

        if (activationTime < 0) {
            activationTime = 0; // Ensure activation time is not negative
        }


        
        return new Point2D[]{initialSpeedVector, new Point2D(timeOfFlight + 0.05f, activationTime)};
    }*/

    public static final double PROJECTILE_LIFE_TIME = 5f; // Life time of the projectile

    @Override
    public Point2D[] getSpeedVector(Point2D startingPoint, Point2D targetPoint, float gravity) {
        
        Point2D speedVector = targetPoint.subtract(startingPoint); // Calculate the speed vector from the starting point to the target point
        
        
        double length = speedVector.magnitude(); // Get the length of the speed vector

        if (length > 0) {
            speedVector = speedVector.normalize(); // Normalize the speed vector to get the direction
        } else {
            return new Point2D[]{new Point2D(0, 0), new Point2D(0, 0.1)}; // If the length is zero, return a zero vector
        }

        return new Point2D[]{speedVector, new Point2D(PROJECTILE_LIFE_TIME, 0)}; // Return the normalized speed vector
    }


    @Override
    public float getGravityFactor() {
        return GRAVITY;
    }

    @Override
    public float getSpeed() {
        return ARTILLERY_SPEED;
    }
}
package com.kurabiye.kutd.model.Projectile.ProjectileMoveStrategy;

import com.kurabiye.kutd.model.Coordinates.Point2D;

public class ArrowProjectileMoveStrategy implements IProjectileMoveStrategy {


    private static final double PROJECTILE_LIFE_TIME = 5f; // Life time of the projectile


    private static final float PROJECTILE_SPEED = 800.0f; // Speed of the projectile

    @Override
    public Point2D[] getSpeedVector(Point2D startingPoint, Point2D targetPoint, float gravity) {
        
        Point2D speedVector = targetPoint.subtract(startingPoint); // Calculate the speed vector from the starting point to the target point
        
        
        double length = speedVector.magnitude(); // Get the length of the speed vector

        if (length > 0) {
            speedVector = speedVector.normalize(); // Normalize the speed vector to get the direction
        } else {
            return new Point2D[]{new Point2D(0, 0), new Point2D(PROJECTILE_LIFE_TIME, 0.1)}; // If the length is zero, return a zero vector
        }

        return new Point2D[]{speedVector, new Point2D(length/PROJECTILE_SPEED + 3, 0)}; // Return the normalized speed vector
    }

    @Override
    public float getGravityFactor() {
        return 0; // Straight line movement does not consider gravity, so return 0
    }

    @Override
    public float getSpeed() {
        return PROJECTILE_SPEED;
    }




  


}
package com.kurabiye.kutd.model.Projectile;

// WHEN THE PROJECTILE IS GONNA DAMAGE THE TARGET
    public enum DamageType { // Enum for damage types
        AREA,
        TARGET
    }
package com.kurabiye.kutd.model.Projectile;


import com.kurabiye.kutd.model.Coordinates.Point2D;
import com.kurabiye.kutd.model.Player.UserPreference;


import com.kurabiye.kutd.model.Projectile.ProjectileMoveStrategy.ArrowProjectileMoveStrategy;
import com.kurabiye.kutd.model.Projectile.ProjectileMoveStrategy.ArtilleryProjectileMoveStrategy;
import com.kurabiye.kutd.model.Projectile.ProjectileMoveStrategy.IProjectileMoveStrategy;
import com.kurabiye.kutd.model.Projectile.ProjectileMoveStrategy.MagicProjectileMoveStrategy;


public class ProjectileFactory {

    private static ProjectileFactory instance; // Singleton instance

    private float artilleryRange;
    
    // Private constructor to prevent instantiation from outside
    private ProjectileFactory() {
        // Private constructor implementation
        artilleryRange = UserPreference.getInstance().getArtilleryRange(); // Get the artillery range from user preferences
    }
    
    // Method to get the singleton instance of the ProjectileFactory
    public static synchronized ProjectileFactory getInstance() {
        if (instance == null) {
            instance = new ProjectileFactory();
        }
        return instance;
    }

    // Create a projectile of a specific type with default values
    public Projectile createProjectile(Projectile.ProjectileType projectileType, Point2D startCoordinate, Point2D targetCoordinate) {
        // Create a new projectile with the specified type and default values from user preferences
        float projectileAreaDamage = 40f; // Default area damage for the projectile
        IProjectileMoveStrategy moveStrategy = null; // Initialize the move strategy
        DamageType explosionType = DamageType.TARGET; // Default explosion type for the projectile
        switch (projectileType) {
            case ARROW:
                moveStrategy = new ArrowProjectileMoveStrategy(); // Set the move strategy for arrow projectiles
                break;
            case MAGIC:
                moveStrategy = new MagicProjectileMoveStrategy(); // Set the move strategy for magic projectiles
                break;
            case ARTILLERY:
                moveStrategy = new ArtilleryProjectileMoveStrategy(); // Set the move strategy for artillery projectiles
                projectileAreaDamage = artilleryRange * projectileAreaDamage; // Set the area damage for artillery projectiles
                explosionType = DamageType.AREA; // Set the explosion type for artillery projectiles
                break;
            default:
                throw new IllegalArgumentException("Invalid projectile type: " + projectileType); // Handle invalid projectile types
        }

        Projectile product = new Projectile(projectileType,
                startCoordinate, // Starting coordinate of the projectile
                targetCoordinate, // Target coordinate of the projectile       
                moveStrategy,
                projectileAreaDamage,
                explosionType); // Create a new projectile with the specified parameters
               


        
        return product; // Return the created projectile
        
    }
}
package com.kurabiye.kutd.model.Projectile;

import com.kurabiye.kutd.model.Coordinates.Point2D;
import com.kurabiye.kutd.model.Projectile.Projectile.ProjectileType;

/**
 * Interface defining the core functionality of a Projectile in the tower defense game.
 * Projectiles are fired by towers and move towards enemies, dealing damage on impact.
 * 
 * @author Atlas Berk Polat
 * @version 1.2
 * @since 2025-05-02
 */
public interface IProjectile {
    
    /**
     * Gets the type of projectile
     * 
     * @return The projectile type
     */
    ProjectileType getProjectileType();
    
    /**
     * Gets the area of damage effect for the projectile
     * 
     * @return The area damage value (radius)
     */
    float getProjectileAreaDamage();
    
    /**
     * Updates the projectile's position based on its speed vector and delta time
     * 
     * @param deltaTime Time passed since last update
     */
    void move(double deltaTime);
    
    /**
     * Gets the current position of the projectile
     * 
     * @return The projectile's coordinate
     */
    Point2D getCoordinate();

    /**
     * Get the speed vector of the projectile
     */
    Point2D getSpeedVector();

    /**
     * get the projectile state
     * 
     * @return the projectile state
     */

     ProjectileState getProjectileState();

     /**
      * get the explosion type

        * @return the explosion type
      */

      DamageType getDamageType();

      /**
       * Get the target coordinate of the projectile
       * 
       * @return The target coordinate
       */
        Point2D getTarget();
    
}package com.kurabiye.kutd.model.Enemy;

public enum EnemyState { // Enum for enemy states
        ALIVE, // Enemy is alive
        DEAD, // Enemy is dead
        ARRIVED // Enemy has arrived at the destination
    }
package com.kurabiye.kutd.model.Enemy;

import java.util.ArrayList;

import com.kurabiye.kutd.model.Coordinates.Point2D;
import com.kurabiye.kutd.model.Enemy.MoveStrategy.IMoveStrategy;
import com.kurabiye.kutd.model.Projectile.Projectile.ProjectileType;


/*
 * This class represents an enemy in the game.
 * It contains attributes such as health, speed, and kill reward.
 * It also provides methods to damage the enemy and check if it is alive.
 * 
 * 
 * @author: Atlas Berk Polat
 * @version: 1.0
 * @since: 2025-04-23
 */

public class Enemy implements IEnemy {

    
    private EnemyType enemyType; // Type of the enemy

    private Point2D coordinate = new Point2D(0,0); // Coordinate of the enemy on the map

    private int killReward; // Default health for enemies

    private float health; // Enemy's health

    private int speed; // Enemy's speed

    private float[] damageDealtOfProjectiles;

    // This is a normalized vector
    // It is used to calculate the direction of the enemy's movement 
    private Point2D moveDirection = new Point2D(1, 0); // Direction of the enemy's movement
    
    

    private EnemyState enemyState = EnemyState.ALIVE; // Enemy's alive status

    //  Keep track of where the enemy is on the path
    private int pathPointIndex = 0; // Index of the current path point



    // For the moment it will be only the center of the tiles
    private ArrayList<Point2D> movePath = new ArrayList<Point2D>(); // Path of the enemy


    /*
     * For the moment we do not implement any move strategy.
     * The enemies will move from one center of the tile to another center of the tile.
     * The move sttategy will use math and geometry to create more complex paths later.
     * 
     */
    
     public void setMovePathWithStrategy(ArrayList<Point2D> path, IMoveStrategy moveStrategy) {
        
         this.movePath = moveStrategy.createMovePath(path); // Create the move path using the strategy
     }

    public Enemy(EnemyType enemyType, int health, int speed, int killReward, float[] damageDealtOfProjectiles) {
        this.enemyType = enemyType; // Set the type of the enemy
        this.health = (float) health; // Set the health of the enemy
        this.speed = speed; // Set the speed of the enemy
        this.killReward = killReward; // Set the kill reward for the enemy
        this.damageDealtOfProjectiles = damageDealtOfProjectiles; // Set the damage dealt by projectiles
    }

    public synchronized void getDamage(ProjectileType projectileType) {

        float damage = damageDealtOfProjectiles[projectileType.getValue()]; // Get the damage dealt by the projectile
        health -= damage; // Reduce the health of the enemy by the damage dealt

        if(health <= 0) {
            enemyState = EnemyState.DEAD; // Set the enemy
            return; // If the enemy's health is less than or equal to 0, set the enemy state to DEAD
        }


        /*
         * Teleporting the enemey to the starting point of the path
         * with the 3 perceent chance.
         * 
         * 
         */

        if(Math.random() < 0.03) { // 3% chance to teleport the enemy back to the start of the path
            pathPointIndex = 0; // Reset the path point index to 0
            coordinate = movePath.get(0); // Set the coordinate of the enemy to the first point in the path
    }
}

    public int getKillReward() {
        if(enemyState == EnemyState.DEAD) {
            return killReward; // If the enemy is dead
        } else {
            return 0; // If the enemy is alive
        }
    }

    public synchronized void move(double deltaTime){

        
        if(enemyState == EnemyState.DEAD || enemyState == EnemyState.ARRIVED) {
            return; // If the enemy is not alive, do not move
        }

        Point2D nextPoint = movePath.get(pathPointIndex); // Get the next point on the path

        if(this.coordinate.distance(nextPoint) < speed * deltaTime) {
            pathPointIndex++; // Increment the path point index

            // Check if pathPointIndex is within the range of movePath
            
            if (pathPointIndex >= movePath.size()) {
            // Enemy has reached the end of the path
            enemyState = EnemyState.ARRIVED;
            return;
        }
            nextPoint = movePath.get(pathPointIndex); // Get the next point on the path
        }

        Point2D distanceVector = nextPoint.subtract(coordinate); // Calculate the distance vector to the next point
        // Normalize the distance vector
        double distance = distanceVector.magnitude(); // Calculate the magnitude of the distance vector
        if(distance > 0) {
            distanceVector = distanceVector.multiply(speed * deltaTime / distance); // Scale the distance vector by speed and delta time
        }
        coordinate = coordinate.add(distanceVector); // Update the coordinate of the enemy


        // Set the move direction of the enemy

        moveDirection = distanceVector.normalize(); // Set the move direction to the distance vector

    }


    public synchronized boolean isAlive() {
        return (enemyState == EnemyState.ALIVE); // Check if the enemy is alive
    }

    public synchronized boolean isDead() {
        return (enemyState == EnemyState.DEAD); // Check if the enemy is dead
    }

    public synchronized boolean hasArrived() {
        return (enemyState == EnemyState.ARRIVED); // Check if the enemy has arrived at the destination
    }

    public synchronized float getHealth() {
        return health; // Get the health of the enemy
    }
    public int getSpeed() {
        return speed; // Get the speed of the enemy
    }
    public synchronized Point2D getCoordinate() {
        return coordinate; // Get the coordinate of the enemy
    }

    /*
     * 
     * This method is used to set the coordinate of the enemy to a new coordinate.
     * It is used when the enemy is spawned or when it is moved to a new location.
     * 
     * @param coordinate The new coordinate of the enemy.
     */
    public synchronized void locate(Point2D newCoordinate) {
        this.coordinate = newCoordinate; // Set the coordinate of the enemy to the new point
    }

    public EnemyType getEnemyType() {
        return enemyType; // Get the type of the enemy
    }

    public synchronized Point2D getMoveDirection() {
        return moveDirection; // Get the move direction of the enemy
    }

    public synchronized void setSpeed(int speed) {
        this.speed = speed; // Set the speed of the enemy
    }


}
package com.kurabiye.kutd.model.Enemy.MoveStrategy;

import java.util.ArrayList;

import com.kurabiye.kutd.model.Coordinates.Point2D;

public interface IMoveStrategy {

    // This interface defines the move strategy for enemies
    // It contains a method to define how the enemy moves

    ArrayList<Point2D> createMovePath(ArrayList<Point2D> path); // Method to define the movement of the enemy

}
package com.kurabiye.kutd.model.Enemy.MoveStrategy;

import java.util.ArrayList;
import java.util.Random;

import com.kurabiye.kutd.model.Coordinates.Point2D;


/* GoblinMoveStrategy.java
 * This class implements the IMoveStrategy interface and defines the move strategy for the Goblin enemy.
 * It currently does not modify the path, but can be extended in the future.
 * I leave it as non-singleton for now, but it can be changed to singleton if needed.
 * But I believe we can add more stateful methods to this class in the future.
 * 
 * 
 * @author: Atlas Berk Polat
 * @version: 1.0
 * @since: 2025-05-01
 * 
 */

public class GoblinMoveStrategy implements IMoveStrategy {


    Random random = new Random();


    private static final double THRESHOLD = 10; // Threshold for checking if two points are equal

    @Override
    public ArrayList<Point2D> createMovePath(ArrayList<Point2D> path) {


        ArrayList<Point2D> newPath = new ArrayList<Point2D>();



        // Check the tiles as three groups
        // If they are in the same 


        for(int i = 1; i < path.size() - 1; i++) {
            Point2D start = path.get(i -1);
            Point2D mid = path.get(i);
            Point2D end = path.get(i + 1);

            // check if the tiles create a straight line

            Point2D difVect1 = new Point2D(mid.getX() - start.getX(), mid.getY() - start.getY());
            Point2D difVect2 = new Point2D(end.getX() - mid.getX(), end.getY() - mid.getY());

            // check if the tiles create a straight line
            if(difVect1.dotProduct(difVect2) > THRESHOLD) {
                // if they are in the same line, add the middle tile to the new path
                
                // slightly change the mid point

                // check if the straigth line is horizontal or vertical

                Point2D newMid = new Point2D(mid.getX(), mid.getY());

                if(Math.abs(difVect1.getX()) > Math.abs(difVect1.getY())) {
                    // horizontal line
                    newMid.add(newMid.getX() * (random.nextDouble() * 0.5 - 1), 0);
                } else {
                    // vertical line
                    newMid.add(0, newMid.getY() * (random.nextDouble() * 0.5 - 1));
                }

                newPath.add(newMid);


            } else {
                
                // if not in the same line, find the middle of the end and start tiles

                Point2D mPoint2D = start.midpoint(end);

                // then find the middle of mPoint2D and mid

                // pick a random point between mid and mPoint2D
                // this is the new middle point

                // pick a random number between 0.25 and 0.5
                double randomNum = random.nextDouble() * 0.4 + 0.25;

                Point2D mPoint2D2 = mid.interpolate(mPoint2D, randomNum);

                // add the middle point to the new path

                newPath.add(mPoint2D2);
            }   

        }
        return newPath;
        
    }


}
package com.kurabiye.kutd.model.Enemy.MoveStrategy;

import java.util.ArrayList;
import java.util.Random;

import com.kurabiye.kutd.model.Coordinates.Point2D;

/* KnightMoveStrategy.java
 * This class implements the IMoveStrategy interface and defines the move strategy for the Knight enemy.
 * It currently does not modify the path, but can be extended in the future.
 * I leave it as non-singleton for now, but it can be changed to singleton if needed.
 * But I believe we can add more stateful methods to this class in the future.
 * 
 * 
 * @author: Atlas Berk Polat
 * @version: 1.0
 * @since: 2025-05-01
 * 
 */

public class KnightMoveStrategy implements IMoveStrategy {

   Random random = new Random();


    private static final double THRESHOLD = 10; // Threshold for checking if two points are equal

    @Override
    public ArrayList<Point2D> createMovePath(ArrayList<Point2D> path) {


        ArrayList<Point2D> newPath = new ArrayList<Point2D>();



        // Check the tiles as three groups
        // If they are in the same 


        for(int i = 1; i < path.size() - 1; i++) {
            Point2D start = path.get(i -1);
            Point2D mid = path.get(i);
            Point2D end = path.get(i + 1);

            // check if the tiles create a straight line

            Point2D difVect1 = new Point2D(mid.getX() - start.getX(), mid.getY() - start.getY());
            Point2D difVect2 = new Point2D(end.getX() - mid.getX(), end.getY() - mid.getY());

            // check if the tiles create a straight line
            if(difVect1.dotProduct(difVect2) > THRESHOLD) {
                // if they are in the same line, add the middle tile to the new path
                newPath.add(mid);
            } else {
                
                // if not in the same line, find the middle of the end and start tiles

                Point2D mPoint2D = start.midpoint(end);

                // then find the middle of mPoint2D and mid

                // pick a random point between mid and mPoint2D
                // this is the new middle point

                // pick a random number between 0.25 and 0.5
                double randomNum = random.nextDouble() * 0.25 + 0.25;

                Point2D mPoint2D2 = mid.interpolate(mPoint2D, randomNum);

                // add the middle point to the new path

                newPath.add(mPoint2D2);
            }   

        }
        return newPath;
        
    }
   

}
package com.kurabiye.kutd.model.Enemy;

import java.util.ArrayList;

import com.kurabiye.kutd.model.Coordinates.Point2D;

import com.kurabiye.kutd.model.Enemy.MoveStrategy.IMoveStrategy;
import com.kurabiye.kutd.model.Projectile.Projectile.ProjectileType;

/**
 * Interface defining the core functionality of an Enemy in the tower defense game.
 * Enemies move along a path towards a destination and can be damaged by towers.
 * 
 * @author Atlas Berk Polat
 * @version 1.5
 * @since 2025-04-20
 */
public interface IEnemy {
    
    /**
     * Sets the path for the enemy to follow using a movement strategy
     * 
     * @param path The path points to follow
     * @param moveStrategy The strategy that controls how the enemy moves
     */
    void setMovePathWithStrategy(ArrayList<Point2D> path, IMoveStrategy moveStrategy);


    
    /**
     * Applies damage to the enemy when hit by a projectile
     * 
     * @param projectileType The type of projectile that hit the enemy
     */
    void getDamage(ProjectileType projectileType);
    
    /**
     * Gets the gold reward when the enemy is killed
     * 
     * @return The amount of gold awarded
     */
    int getKillReward();
    
    /**
     * Updates the enemy's position based on deltaTime
     * 
     * @param deltaTime Time passed since last update in milliseconds
     */
    void move(double deltaTime);
    
    /**
     * Checks if the enemy is alive
     * 
     * @return true if the enemy is alive, false otherwise
     */
    boolean isAlive();
    
    /**
     * Checks if the enemy is dead
     * 
     * @return true if the enemy is dead, false otherwise
     */
    boolean isDead();
    
    /**
     * Checks if the enemy has arrived at the destination
     * 
     * @return true if the enemy has arrived, false otherwise
     */
    boolean hasArrived();
    
    /**
     * Gets the current health of the enemy
     * 
     * @return The enemy's health
     */
    float getHealth();
    
    /**
     * Gets the speed of the enemy
     * 
     * @return The enemy's speed
     */
    int getSpeed();
    
    /**
     * Gets the current position of the enemy
     * 
     * @return The enemy's coordinate
     */
    Point2D getCoordinate();

    /**
     * Gets the move direction of the enemy
     * 
     * @return The direction vector the enemy is moving towards
     */
    Point2D getMoveDirection();
    
    /**
     * Sets the position of the enemy
     * 
     * @param newCoordinate The new coordinate to place the enemy
     */
    void locate(Point2D newCoordinate);
    
    /**
     * Gets the type of the enemy
     * 
     * @return The enemy type
     */
    EnemyType getEnemyType();

    /**
     * sets the enemy speed
     * 
     * @param speed
     */

    void setSpeed(int speed); // Set the speed of the enemy


    /**
     * Set the coordinate of the enemy to a new coordinate.
     * Use the points of the path to set the coordinate.
     * 
     * @param trayPointIndex The index of the point in the path to set as the new coordinate
     * @throws IndexOutOfBoundsException if the index is out of bounds of the path
     */

}package com.kurabiye.kutd.model.Enemy.Decorators;

import java.util.ArrayList;

import com.kurabiye.kutd.model.Coordinates.Point2D;
import com.kurabiye.kutd.model.Enemy.EnemyType;
import com.kurabiye.kutd.model.Enemy.IEnemy;
import com.kurabiye.kutd.model.Enemy.MoveStrategy.IMoveStrategy;
import com.kurabiye.kutd.model.Projectile.Projectile.ProjectileType;

public abstract class EnemyDecorator implements IEnemy {

    // This class is an abstract decorator for the IEnemy interface
    // It can be used to add additional functionality to the IEnemy interface
    // without modifying the original interface or its implementations

    protected IEnemy enemy;

    public EnemyDecorator(IEnemy enemy) {
        this.enemy = enemy; // Initialize the decorator with an IEnemy instance
    }

    @Override
    public void setMovePathWithStrategy(ArrayList<Point2D> path, IMoveStrategy moveStrategy) {
        enemy.setMovePathWithStrategy(path, moveStrategy);
    }

    @Override
    public void getDamage(ProjectileType projectileType) {
        enemy.getDamage(projectileType);
    }

    @Override
    public int getKillReward() {
        return enemy.getKillReward();
    }

    @Override
    public void move(double deltaTime) {
        enemy.move(deltaTime);
    }

    @Override
    public boolean isAlive() {
        return enemy.isAlive();
    }

    @Override
    public boolean isDead() {
        return enemy.isDead();
    }

    @Override
    public boolean hasArrived() {
        return enemy.hasArrived();
    }

    @Override
    public float getHealth() {
        return enemy.getHealth();
    }

    @Override
    public int getSpeed() {
        return enemy.getSpeed();
    }

    @Override
    public Point2D getCoordinate() {
        return enemy.getCoordinate();
    }

    @Override
    public void locate(Point2D newCoordinate) {
        enemy.locate(newCoordinate);
    }

    @Override
    public EnemyType getEnemyType() {
        return enemy.getEnemyType();
    }

    @Override
    public void setSpeed(int speed) {
        enemy.setSpeed(speed);
    }

     /** 
     * This method is used to remove the decoration from the enemy.
     * It returns the original enemy without any decoration.
     * * @return The original enemy without decoration.
     */
    public IEnemy removeDecoration() {
        return enemy; // Return the original enemy without decoration
    }

    @Override
    public Point2D getMoveDirection() {
        return enemy.getMoveDirection();
    }


}
package com.kurabiye.kutd.model.Enemy.Decorators;
import com.kurabiye.kutd.model.Enemy.IEnemy;


/**
 * SynergeticMoveDecorator is a decorator for the IEnemy interface that adds synergetic movement behavior.
 * It extends the EnemyDecorator class to provide additional functionality to the enemy's movement.
 * 
 * @author Atlas Berk Polat
 * @version 1.0
 * @since 2025-05-28
 */

public class SynergeticMoveDecorator extends EnemyDecorator {

    // This class is a decorator for the IEnemy interface
    // It adds synergetic movement behavior to the enemy

    private int goblinSpeed; // Speed of the goblin
    private int knightSpeed; // Speed of the knight

    public SynergeticMoveDecorator(IEnemy enemy, int goblinSpeed, int knightSpeed) {
        super(enemy); // Initialize the decorator with an IEnemy instance
    }

    @Override
    public void move(double deltaTime) {
        // Implement synergetic movement logic here
        // For example, modify the enemy's move direction based on some conditions
        super.move(deltaTime); // Call the original move method from the decorated enemy
    }

    public void applySynergeticMovement() {
        // Implement the synergetic movement logic here
        // This could involve modifying the enemy's path or speed based on certain conditions
        // For example, if the enemy is a goblin, it might move faster when near a knight
        enemy.setSpeed((goblinSpeed + knightSpeed) / 2); // Example of combining speeds);
    }

    @Override
    public IEnemy removeDecoration(){
        // This method can be used to remove the decoration and return the original enemy

        enemy.setSpeed(knightSpeed);

        return enemy; // Return the original enemy without the synergetic movement behavior
    }

}
package com.kurabiye.kutd.model.Enemy.Decorators;

import com.kurabiye.kutd.model.Enemy.IEnemy;


/**
 * Slowdown is a decorator for the IEnemy interface that adds synergetic movement behavior.
 * It extends the EnemyDecorator class to provide additional functionality to the enemy's movement.
 * 
 * @author Atlas Berk Polat
 * @version 1.0
 * @since 2025-04-23
 */

public class SlowDownDecorator extends EnemyDecorator {

    // This class is a decorator for the IEnemy interface
    // It adds synergetic movement behavior to the enemy

    private int originalSpeed; // Original speed of the enemy

    public SlowDownDecorator(IEnemy enemy) {
        super(enemy); // Initialize the decorator with an IEnemy instance
    }

    @Override
    public void move(double deltaTime) {
        // Implement synergetic movement logic here
        // For example, modify the enemy's move direction based on some conditions
        super.move(deltaTime); // Call the original move method from the decorated enemy
    }

    public void applySlowDown(float slowDownRate) {
        // Implement the synergetic movement logic here
        // This could involve modifying the enemy's path or speed based on certain conditions
        // For example, if the enemy is a goblin, it might move faster when near a knight
        originalSpeed = enemy.getSpeed(); // Store the original speed

        enemy.setSpeed((int) (enemy.getSpeed() / slowDownRate)); // Example of combining speeds);
    }

    @Override
    public IEnemy removeDecoration(){
        // This method can be used to remove the decoration and return the original enemy

        enemy.setSpeed(originalSpeed);

        return enemy; // Return the original enemy without the synergetic movement behavior
    }

}
package com.kurabiye.kutd.model.Enemy;

public enum EnemyType { // Enum for different enemy types
        GOBLIN(0), // Goblin enemy type
        KNIGHT(1); // Knight enemy type
        
        private final int value;
        
        EnemyType(int value) {
            this.value = value;
        }
        
        public int getValue() {
            return value;
        }
    }
package com.kurabiye.kutd.model.Enemy;

import java.util.ArrayList;


import com.kurabiye.kutd.model.Coordinates.Point2D;

import com.kurabiye.kutd.model.Enemy.MoveStrategy.GoblinMoveStrategy;
import com.kurabiye.kutd.model.Enemy.MoveStrategy.KnightMoveStrategy;
import com.kurabiye.kutd.model.Player.UserPreference;

/* EnemyFactory.java
 * This class is responsible for creating different enemy objects.
 * It uses the Factory design pattern to create instances of different enemy types.
 * userPreferences.java will help to get the necessary data from the user with regard to enemy health, speed, and kill reward.
 * 
 * 
 * 
 * 
 * @author: Atlas Berk Polat
 * @version: 1.0
 * @since: 2025-04-29
 */

public class EnemyFactory {

    // Static instance for Singleton pattern
    private static EnemyFactory instance;

    private static UserPreference userPreferences = UserPreference.getInstance(); // User preferences object
    
    // Pre-defined damage values for different projectile types against different enemy types
    // Format: [ProjectileType][EnemyType]
    private final float[][] DEFAULT_DAMAGE_VALUES;

    private ArrayList<Point2D> enemyPath; // Path for enemies to follow
    
    // Private constructor to prevent instantiation from outside
    private EnemyFactory() {
        // Private constructor for singleton pattern
        DEFAULT_DAMAGE_VALUES = transposeArray(userPreferences.getDamageDealt());
    }
    
    // Get the singleton instance of EnemyFactory
    public static synchronized EnemyFactory getInstance() {
        if (instance == null) {
            instance = new EnemyFactory();
        }
        return instance;
    }
    

    // Create an enemy of a specific type with default values
    public Enemy createEnemy(EnemyType enemyType) {
        
        Enemy my_enemy = new Enemy(enemyType,
        userPreferences.getEnemyHealth()[enemyType.getValue()],
        userPreferences.getEnemyMovementSpeed()[enemyType.getValue()],
        userPreferences.getGoldPerEnemy()[enemyType.getValue()], 
        DEFAULT_DAMAGE_VALUES[enemyType.getValue()]);

        switch (enemyType) {
            case EnemyType.GOBLIN:

            my_enemy.setMovePathWithStrategy(enemyPath, new GoblinMoveStrategy());       
                break;

            case EnemyType.KNIGHT:

            my_enemy.setMovePathWithStrategy(enemyPath, new KnightMoveStrategy()); 
                break;
            default:
                throw new IllegalArgumentException("Invalid enemy type: " + enemyType);

        }

        my_enemy.locate(enemyPath.get(0)); // Set the initial position of the enemy to the first point in the path

        return my_enemy;
    }

    public Enemy createEnemy(int enemyType) {
        return createEnemy(EnemyType.values()[enemyType]);
    }


    /**
 * Transposes a 2D array 
 */
    private static float[][] transposeArray(float[][] original) {
    int rows = original.length;
    int cols = original[0].length;
    
    float[][] transposed = new float[cols][rows];

    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            transposed[j][i] = original[i][j];
        }
    }

    return transposed;
    }

    // set the enemy path
    public void setEnemyPath(ArrayList<Point2D> enemyPath) {
        this.enemyPath = enemyPath; // Set the path for enemies to follow
    }
    
    
}
package com.kurabiye.kutd.model.Collectable;

/*  ICollectable.java
 *  This interface is used to define a collectable item.
 *  It is a generic interface that can be used with any type of item.
 *  
 *  @author: Atlas Berk Polat
 *  @version: 2.0
 *  @since: 2025-09-25
 */

public interface ICollectable<T> {


    T getItem();


}
package com.kurabiye.kutd.model.Map;

import java.io.Serializable;
import java.util.List;

/* * GameMapRepository.java
 * This class is responsible for managing the game map data, including loading and saving map data,
 * and providing access to the map data for other components of the game.
 * 
 * 
 * @author: Atlas Berk Polat
 * @version: 1.0
 * @since: 2025-04-28
 */

public class GameMapRepository implements Serializable{

        private static final long serialVersionUID = 1L; // Unique ID for serialization

        private static GameMapRepository instance; // Singleton instance of GameMapRepository

        private List<GameMap> gameMaps; // List of game maps

        private GameMapRepository() {
            // Private constructor to prevent instantiation
        }


        public static GameMapRepository getInstance() {
            if (instance == null) {
                instance = new GameMapRepository(); // Create a new instance if it doesn't exist
            }
            return instance; // Return the singleton instance
        }


        public List<GameMap> getGameMaps() {
            return gameMaps; // Return the list of game maps
        }

        public void addGameMap(GameMap gameMap) {
            gameMaps.add(gameMap); // Add a new game map to the list
        }

        public void removeGameMap(GameMap gameMap) {
            gameMaps.remove(gameMap); // Remove a game map from the list
        }

        public void removeGameMap(int index) {
            if (index >= 0 && index < gameMaps.size()) {
                gameMaps.remove(index);
            } else {
                throw new IndexOutOfBoundsException("Invalid map index: " + index);
            }
        }

        private Object readResolve() {
            // Ensure that the singleton instance is returned during deserialization
            return getInstance();
        }

}
package com.kurabiye.kutd.model.Map;

import java.util.ArrayList;
import java.util.List;

import com.kurabiye.kutd.model.Coordinates.Point2D;
import com.kurabiye.kutd.model.Coordinates.TilePoint2D;
import com.kurabiye.kutd.model.Tile.Tile;
import com.kurabiye.kutd.model.Tile.TileFactory;
import com.kurabiye.kutd.util.ObserverPattern.Observable;
import com.kurabiye.kutd.util.ObserverPattern.Observer;

public class GameMap implements Observable{

    private static final Tile ERROR_TILE = new Tile(1);

    public static final int MAP_WIDTH = 16; // Width of the map
    public static final int MAP_HEIGHT = 9; // Height of the map

    /* [0] 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 x-axis
     * [1] 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
     *   .
     *   .
     * [8] 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
     * y-axis
     * 
     *  The map is represented as a 2D array of tiles.
     *  Each tile has a specific code that determines its type.
     * 
     *  The map is divided into a grid of tiles, and each tile has a width and height.
     * tiles[y-axis][x-axis]
     */ 
    private Tile[][] tiles; // 2D array representing the tiles on the map it will

    private int startTileDirection = -1; // Direction of the starting tile
    private int endTileDirection = -1; // Direction of the ending tile

    private TilePoint2D startTileCoordinates; // Starting tile of the map
    private TilePoint2D endTileCoordinates; // Ending tile of the map

    private List<Point2D> pointPath; // List of path tiles on the map

    private List<Tile> tilePath;


    public GameMap() {
        tiles = new Tile[MAP_HEIGHT][MAP_WIDTH]; // Initialize the tiles array
    }

    public GameMap(Tile[][] tiles, TilePoint2D startTileCoordinates, TilePoint2D endTileCoordinates) {
        if (tiles.length != MAP_HEIGHT || tiles[0].length != MAP_WIDTH) {
            throw new IllegalArgumentException("Invalid tile array dimensions");
        }
        this.tiles = tiles; // Initialize the tiles array with the provided tiles

        this.startTileCoordinates = startTileCoordinates; // Set the starting tile
        this.endTileCoordinates = endTileCoordinates; // Set the ending tile

        int[] startTileDirections = tiles[startTileCoordinates.getTileY()][startTileCoordinates.getTileX()].getTileDirections();
        int[] endTileDirections = tiles[endTileCoordinates.getTileY()][endTileCoordinates.getTileX()].getTileDirections();


        // Set up the starting and ending tile directions
        // If the starting tile in on the bottom edge and the tile has a direction 3 then set the staring tile direction to 3
        

        if (startTileCoordinates.getTileY() == MAP_HEIGHT - 1 && (startTileDirections[0] == 3 || startTileDirections[1] == 3)) {
            startTileDirection = 3;
        }
        // If the starting the starting tile is on the left edge and the tile has a direction 0 then set the staring tile direction to 0

        if (startTileCoordinates.getTileX() == 0 && (startTileDirections[0] == 0 || startTileDirections[1] == 0)) {
            startTileDirection = 0;
        }

        // If the starting the starting tile is on the right edge and the tile has a direction 2 then set the staring tile direction to 2
        if (startTileCoordinates.getTileX() == MAP_WIDTH - 1 && (startTileDirections[0] == 2 || startTileDirections[1] == 2)) {
            startTileDirection = 2;
        }

        // If the starting the starting tile is on the top edge and the tile has a direction 1 then set the staring tile direction to 1
        if (startTileCoordinates.getTileY() == 0 && (startTileDirections[0] == 1 || startTileDirections[1] == 1)) {
            startTileDirection = 1;
        }

        if (startTileDirection == -1) {
            throw new IllegalArgumentException("Invalid starting tile direction");
        }

        // Do the same for the ending tile


        if (endTileCoordinates.getTileY() == MAP_HEIGHT - 1 && (endTileDirections[0] == 1 || endTileDirections[1] == 1)) {
            endTileDirection = 1;
        }

        if (endTileCoordinates.getTileX() == 0 && (endTileDirections[0] == 0 || endTileDirections[1] == 0)) {
            endTileDirection = 0;
        }

        if (endTileCoordinates.getTileX() == MAP_WIDTH - 1 && (endTileDirections[0] == 2 || endTileDirections[1] == 2)) {
            endTileDirection = 2;

        }

        if (endTileCoordinates.getTileY() == 0 && (endTileDirections[0] == 3 || endTileDirections[1] == 3)) {
            endTileDirection = 3;
        }

        if (endTileDirection == -1) {
            throw new IllegalArgumentException("Invalid ending tile direction");
        }




    }


    /*
     * The following two methods are synchronized to ensure thread safety.
     * 
     * 
     */

    public synchronized Tile getTile(int x, int y) {
        if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) {
            throw new IllegalArgumentException("Coordinates out of bounds");
        }
        return tiles[y][x]; // Return the tile at the specified coordinates
    }

    public synchronized void setTile(int x, int y, Tile tile) {
        if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) {
            throw new IllegalArgumentException("Coordinates out of bounds");
        }
        tiles[y][x] = tile;
        notifyObservers(tile);
         // Set the tile at the specified coordinates
    }

    public TilePoint2D getstartTileCoordinates() {
        return startTileCoordinates; // Return the starting tile
    }

    public void setstartTileCoordinates(TilePoint2D startTileCoordinates) {
        this.startTileCoordinates = startTileCoordinates; // Set the starting tile
    }

    public TilePoint2D getendTileCoordinates() {
        return endTileCoordinates; // Return the ending tile
    }

    public void setendTileCoordinates(TilePoint2D endTileCoordinates) {
        this.endTileCoordinates = endTileCoordinates; // Set the ending tile
    }

    public List<Point2D> getPath() {
        return pointPath; // Return the list of path tiles
    }





    public boolean isValidGameMap() {

        // Check if the tiles array is null or has invalid dimensions
        if (tiles == null || tiles.length != MAP_HEIGHT || tiles[0].length != MAP_WIDTH ) {
            return false; // Invalid tiles array
        }

        // check if the tiles have any null values

        for (int i = 0; i < MAP_HEIGHT; i++) {
            for (int j = 0; j < MAP_WIDTH; j++) {
                if (tiles[i][j] == null) {
                    return false; // Invalid tile
                }
            }
        }

        // Check if the starting and ending tiles are null
        if (startTileCoordinates == null || endTileCoordinates == null) {
            return false; // Invalid tiles
        }


        // Check if the starting and ending tiles are within the bounds of the map
        if (startTileCoordinates.getTileX() < 0 || startTileCoordinates.getTileX() >= MAP_WIDTH ||
            startTileCoordinates.getTileY() < 0 || startTileCoordinates.getTileY() >= MAP_HEIGHT ||
            endTileCoordinates.getTileX() < 0 || endTileCoordinates.getTileX() >= MAP_WIDTH ||
            endTileCoordinates.getTileY() < 0 || endTileCoordinates.getTileY() >= MAP_HEIGHT) {
            return false; // Invalid coordinates
        }

        // check if the starting and ending tiles are not the same

        if (startTileCoordinates.getTileX() == endTileCoordinates.getTileX() && startTileCoordinates.getTileY() == endTileCoordinates.getTileY()) {
            return false; // Starting and ending tiles are the same
        }

        // check if the stating and ending tiles are on the edges of the map
        // they are supposed to be on the edges of the map

        if ((startTileCoordinates.getTileX() != 0 && startTileCoordinates.getTileX() != MAP_WIDTH - 1 ) ||
            (startTileCoordinates.getTileY() != 0 && startTileCoordinates.getTileY() != MAP_HEIGHT - 1)) {
            return false; // Starting tile is not on the edge of the map
        }

        if ((endTileCoordinates.getTileX() != 0 && endTileCoordinates.getTileX() != MAP_WIDTH - 1 ) ||
            (endTileCoordinates.getTileY() != 0 && endTileCoordinates.getTileY() != MAP_HEIGHT - 1)) {
            return false; // Ending tile is not on the edge of the map
        }

        // check if the staring tile is a path tile

        if (!tiles[startTileCoordinates.getTileY()][startTileCoordinates.getTileX()].isPathTile()) {
            return false; // Starting tile is not a path tile
        }
        // check if the ending tile is a path tile
        if (!tiles[endTileCoordinates.getTileY()][endTileCoordinates.getTileX()].isPathTile()) {
            return false; // Ending tile is not a path tile
        }

    
        /*check if any of the tile codes 24 25 28 29 are in the path
         *    also check if they are in the correct configuration of
         *     24 25
         *     28 29
         */
        
         for(int i = 0; i < MAP_HEIGHT; i++) {
            for (int j = 0; j < MAP_WIDTH; j++) {
                if (tiles[i][j].getTileCode() == 24){

                    //check if the tile is not on the right or bottom edge of the map

                    if(i == MAP_HEIGHT - 1 || j == MAP_WIDTH - 1) {
                        return false; // Invalid tile
                    }

                    if(tiles[i][j+1].getTileCode() != 25 || tiles[i+1][j].getTileCode() != 28 || tiles[i+1][j+1].getTileCode() != 29) {
                        return false; // Invalid tile
                    }
                }
            }

        }
        
        // Check if there are at least four buildable tiles
        int buildableCount = 0;
        for (int i = 0; i < MAP_HEIGHT; i++) {
            for (int j = 0; j < MAP_WIDTH; j++) {
                if (tiles[i][j].isBuildableTile()) {
                    buildableCount++;
                }
            }
        }
        if (buildableCount < 4) {
            return false; // Insufficient buildable tiles
        }



        // check if there is a single path from the starting tile to the ending tile


        buildTilePath(); // Build the path from the starting tile to the ending tile
        
        // check if the last tile is the error tile

        if (tilePath.get(tilePath.size() - 1) == ERROR_TILE) {
            return false; // Invalid path
        }
        // check if the last tile is the ending tile

        if (tilePath.get(tilePath.size() - 1) != tiles[endTileCoordinates.getTileY()][endTileCoordinates.getTileX()]) {
            return false; // Invalid path
        }



        

        // More conditions will be added later

        // For example, check if the path is one piece

        return true; // Valid game map
    }


    /*
     * This method requires the GameMap to be a valid game map.
     * I do not want to repeat the code in the isValidGameMap method.
     * First check if the game map is valid.
     * Note that build path would add the ERROR_PATH to the end of the arraylist if there is no path
     * 
     */

    public void buildTilePath() {
        
        ArrayList<Tile> my_path = new ArrayList<>(); // List to store the path tiles

        Tile addTile = tiles[startTileCoordinates.getTileY()][startTileCoordinates.getTileX()]; // Get the starting tile
        
        my_path.add(addTile); // Add the starting tile to the path
        

        int currentToDirection = findOtherEndTile(addTile, startTileDirection); // Set the current direction to the starting tile direction

       



        do{
            
           
           

            // Check if only single one of the neighbours is a path tile and not already in the path

            /*
             * Tile directions
             *      1
             * 0 - Tile - 2
             *      3
             */

             Tile targetTile = null; // Initialize the target tile

           if(currentToDirection == 1){
                targetTile = tiles[addTile.getCoordinate().getTileY() - 1][addTile.getCoordinate().getTileX()]; // Get the tile above

           }else if(currentToDirection == 2){
                targetTile = tiles[addTile.getCoordinate().getTileY()][addTile.getCoordinate().getTileX() + 1]; // Get the tile to the right
           }else if(currentToDirection == 3){
                targetTile = tiles[addTile.getCoordinate().getTileY() + 1][addTile.getCoordinate().getTileX()]; // Get the tile below
           }else if(currentToDirection == 0){
                targetTile = tiles[addTile.getCoordinate().getTileY()][addTile.getCoordinate().getTileX() - 1]; // Get the tile to the left
           }else{

                // add the error tile to the path
                my_path.add(ERROR_TILE); // Add the error tile to the path
                break; // Exit the loop if the direction is invalid
            }

            if (targetTile != null && targetTile.isPathTile() && !my_path.contains(targetTile)) {
                // Check if the target tile has a connection in the current direction

                if(convertDirection(currentToDirection) == targetTile.getTileDirections()[0] || 
                    convertDirection(currentToDirection) == targetTile.getTileDirections()[1]) {
                    // If the target tile is a path tile and not already in the path, add it to the path

                    
                    my_path.add(targetTile); // Add the target tile to the path

                    addTile = targetTile; // Update the current tile to the target tile

                    currentToDirection = findOtherEndTile(addTile, convertDirection(currentToDirection)); // Update the current direction to the target tile direction
                   }else{

                    // We've hit a dead end or loop in the path
                    my_path.add(ERROR_TILE);
                    break;

                   }

                
                
            } else {
                // We've hit a dead end or loop in the path
                my_path.add(ERROR_TILE);
                break;
            }

            // Check if we've reached the end tile
            if (addTile.getCoordinate().getTileX() == endTileCoordinates.getTileX() && 
                addTile.getCoordinate().getTileY() == endTileCoordinates.getTileY()) {
            }

        }while (addTile != tiles[endTileCoordinates.getTileY()][endTileCoordinates.getTileX()]); // Loop until the end tile is reached

        if (my_path.contains(ERROR_TILE)) {
        }

        tilePath = my_path; // Return the list of path tiles
    }

    private int findOtherEndTile(Tile tile, int direction) {
        // Find the other end tile of the path
        int otherEndTile = -1;
        if(tile.getTileDirections()[0] == direction) {
            otherEndTile = tile.getTileDirections()[1]; // Get the other end tile in the opposite direction
        } else if (tile.getTileDirections()[1] == direction) {
            otherEndTile = tile.getTileDirections()[0]; // Get the other end tile in the opposite direction
        }
        return otherEndTile;
    }

    private int convertDirection(int direction) {
        // Convert the direction to the opposite direction
        if (direction == 0) {
            return 2; // Convert left to right
        } else if (direction == 1) {
            return 3; // Convert up to down
        } else if (direction == 2) {
            return 0; // Convert right to left
        } else if (direction == 3) {
            return 1; // Convert down to up
        }
        return -1; // Invalid direction
    }


    public void buildPointPath(){
        // Check if the tile path is already built
        if(pointPath != null) {
            return; // Return if the point path is already built
        }
        buildTilePath(); // Build the tile path

        ArrayList<Point2D> pathPoints = new ArrayList<>(); // List to store the path points

        for (Tile tile : tilePath) {
            // Skip tiles with null coordinates or ERROR_TILE
            if (tile != ERROR_TILE && tile.getCoordinate() != null) {
                pathPoints.add(tile.getCoordinate().getCenter()); // Add the tile coordinates to the path points
            }
        }

        // Add on point to the beginning and end of the path
        // So that enemy spawn does not happen on the visible path

        Point2D startPoint = pathPoints.get(0); // Get the starting point


        if(startTileDirection == 0) {
            pathPoints.add(0, startPoint.add(new Point2D(-3 * MAP_WIDTH, 0)));
        }
        else if(startTileDirection == 1) {
            pathPoints.add(0, startPoint.add(new Point2D(0, -3 * MAP_HEIGHT)));
        }
        else if(startTileDirection == 2) {
            pathPoints.add(0, startPoint.add(new Point2D(3 * MAP_WIDTH, 0)));
        }
        else if(startTileDirection == 3) {
            pathPoints.add(0, startPoint.add(new Point2D(0, 3 * MAP_HEIGHT)));
        }


        Point2D endPoint = pathPoints.get(pathPoints.size() - 1); // Get the ending point

        if(endTileDirection == 0) {
            pathPoints.add(endPoint.add(new Point2D(-4 * MAP_WIDTH, 0)));
        }
        else if(endTileDirection == 1) {
            pathPoints.add(endPoint.add(new Point2D(0, -4 * MAP_HEIGHT)));
        }
        else if(endTileDirection == 2) {
            pathPoints.add(endPoint.add(new Point2D(4 * MAP_WIDTH, 0)));
        }
        else if(endTileDirection == 3) {
            pathPoints.add(endPoint.add(new Point2D(0, 4 * MAP_HEIGHT)));
        }


        pointPath = pathPoints; // Return the list of path points
    }

    public List<Point2D> getPointPath() {
        if(pointPath == null) {
            buildPointPath(); // Build the point path if it is not already built
        }
        return pointPath; // Return the list of path points
    }
    public List<Tile> getTilePath() {
        if(tilePath == null) {
            buildTilePath(); // Build the tile path if it is not already built
        }
        return tilePath; // Return the list of path tiles
    }


    /* Static map for the game
     * 
     * 
     */
    /*private static final int[][] map = {
        { 5, 5, 5, 5, 16, 5, 17, 5, 5, 5, 24, 25, 7, 5, 5, 19 },
        { 0, 13, 13, 13, 13, 1, 2, 5, 5, 18, 28, 29, 6, 23, 16, 5 },
        { 4, 15, 5, 15, 5, 22, 8, 13, 13, 9, 1, 9, 10, 5, 5, 5 },
        { 8, 2, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 17, 27, 5 },
        { 5, 7, 19, 18, 5, 5, 5, 0, 1, 2, 21, 5, 5, 31, 5, 5},
        { 5, 7, 5, 5, 20, 0, 13, 10, 15, 8, 13, 2, 5, 5, 5, 5 },
        { 5, 4, 5, 0, 13, 10, 5, 5, 5, 5, 30, 6, 5, 5, 5, 5 },
        { 23, 7, 15, 7, 5, 5, 0, 1, 13, 13, 13, 10, 16, 5, 18, 5 },
        { 5, 8, 13, 10, 5, 5, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5 }
    };*/

    private static final int[][] map = {
        { 5, 5, 5, 5, 16, 5, 17, 5, 5, 5, 24, 25, 7, 5, 5, 19 },
        { 0, 1, 2, 5, 0, 1, 2, 5, 5, 18, 28, 29, 6, 23, 16, 5 },
        { 4, 15, 7, 15, 7, 22, 8, 13, 13, 9, 1, 9, 10, 5, 5, 5 },
        { 8, 2, 8, 9, 10, 5, 5, 5, 5, 5, 5, 5, 5, 17, 27, 5 },
        { 5, 7, 19, 18, 5, 5, 5, 0, 1, 2, 15, 5, 5, 31, 5, 5},
        { 5, 7, 5, 5, 15, 0, 13, 10, 15, 8, 13, 2, 5, 5, 5, 5 },
        { 5, 4, 5, 0, 13, 10, 0, 1, 2, 5, 30, 6, 5, 5, 5, 5 },
        { 23, 7, 15, 7, 5, 5, 4, 18, 8, 13, 13, 10, 16, 5, 18, 5 },
        { 5, 8, 13, 10, 5, 5, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5 }
    };
 
 

    public static GameMap getPrebuiltMap() {
        Tile[][] tiles = new Tile[MAP_HEIGHT][MAP_WIDTH]; // Initialize the tiles array
        TileFactory tileFactory = new TileFactory();

        // Create the tiles and set their properties
        for (int i = 0; i < MAP_HEIGHT; i++) {
            for (int j = 0; j < MAP_WIDTH; j++) {
                Tile tile = tileFactory.create(map[i][j]); // Create a new tile with code using factory
                tile.setCoordinate(new TilePoint2D(j, i)); // Set coordinates for the tile
                tiles[i][j] = tile;
            }
        }

        // Set the starting and ending tiles
        TilePoint2D startTileCoordinates = new TilePoint2D(6, 8);
        TilePoint2D endTileCoordinates = new TilePoint2D(12,0);

        GameMap my_map = new GameMap(tiles, startTileCoordinates, endTileCoordinates); // Return the static map

        my_map.buildTilePath(); // Build the tile path
        my_map.buildPointPath(); // Build the point path

        return my_map; // Return the static map
    }


    /* Convert the Game Map to an 2D array of integers
     * using the tile codes
     * 
     */

    public static int[][] toIntArray(GameMap gameMap) {
        int[][] intArray = new int[MAP_HEIGHT][MAP_WIDTH]; // Initialize the integer array

        for (int i = 0; i < MAP_HEIGHT; i++) {
            for (int j = 0; j < MAP_WIDTH; j++) {
                intArray[i][j] = gameMap.getTile(j, i).getTileCode(); // Get the tile code and set it in the array
            }
        }

        return intArray; // Return the integer array
    }


    /*
     * 
     * Boilerplate code for the Observable interface
     */

    private List<Observer> observers = new ArrayList<>(); // List of observers

    @Override
    public void addObserver(Observer observer) {
        if (observer == null) {
            throw new NullPointerException("Null Observer");
        }
        if (!observers.contains(observer)) {
            observers.add(observer); // Add the observer to the list
        }
    }

    @Override
    public void removeObserver(Observer observer) {
        if (observer == null) {
            throw new NullPointerException("Null Observer");
        }
        if (observers.contains(observer)) {
            observers.remove(observer); // Remove the observer from the list
        }
    }

    @Override
    public void notifyObservers(Object arg) {
        for (Observer observer : observers) {
            observer.update(arg); // Notify each observer with the argument
        }
    }

    /** 
     * Override the equals method to remove the maps with identical tile arrays
     * 
     * @return true if the two GameMap objects are equal, false otherwise
     * */ 
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true; // Check if the same instance
        if (!(obj instanceof GameMap)) return false; // Check if the object is a GameMap

        GameMap other = (GameMap) obj; // Cast the object to GameMap

        // Compare the tile arrays and coordinates
        return java.util.Arrays.deepEquals(this.tiles, other.tiles) &&
               this.startTileCoordinates.equals(other.startTileCoordinates) &&
               this.endTileCoordinates.equals(other.endTileCoordinates);
    }
    

 }
package com.kurabiye.kutd.model.Wave;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.stream.IntStream;

import com.kurabiye.kutd.model.Player.UserPreference;

/*  WaveInfo.java
 *  This class contains information about the waves in the game.
 *  Each instance will be used in a new game session.
 * 
 * 
 * @author: Atlas Berk Polat
 * @version: 1.0
 * @since: 2025-04-29
 */

public class WaveInfo {

    /*
     * 
     * private int numberOfWaves; // Total number of waves in the game
    private int numberOfGroupsPerWave; // Number of groups per wave
    private int numberOfEnemiesPerGroup; // Number of enemies per group
    private int delayBetweenWaves; // Delay between waves in milliseconds
    private int delayBetweenGroups; // Delay between groups in milliseconds
    private int[] enemyComposition; // Composition of types of enemies for a given group or wave
     */

    //private UserPreference userPreferences; // Singleton instance of UserPreference

     private ArrayList<ArrayList<int[]>> waveDecomposition; // Number of groups per wave // Composition of types of enemies for a given group or wave
    
    private int defaultDelayBetweenWaves; // Default delay between waves in milliseconds
    private int defaultDelayBetweenGroups; // Default delay between groups in milliseconds
    


    public WaveInfo(UserPreference userPreferences) {
        //this.userPreferences = userPreferences; // Get the singleton instance of UserPreference

        this.waveDecomposition = userPreferences.getWaveList(); // Get the wave decomposition from user preferences
        
        this.defaultDelayBetweenWaves = userPreferences.getDelayBetweenWaves(); // Get the delay between waves from user preferences
        this.defaultDelayBetweenGroups = userPreferences.getDelayBetweenGroups(); // Get the delay between groups from user preferences

    }

 
    public int getDefaultDelayBetweenWaves() {
        return defaultDelayBetweenWaves; // Return the default delay between waves
    }
    public int getDefaultDelayBetweenGroups() {
        return defaultDelayBetweenGroups; // Return the default delay between groups
    }

    public int getTotalNumberOfWaves() {
        return waveDecomposition.size(); // Return the total number of waves from user preferences
    }

    public int getTotalNumberOfGroupsInWave(int waveIndex) {
        return waveDecomposition.get(waveIndex).size(); // Return the total number of groups in the specified wave
    }

    public int[] getWaveGroupDecomposition(int waveIndex, int groupIndex) {
        return waveDecomposition.get(waveIndex).get(groupIndex).clone(); // Return the decomposition of the specified wave and group clone it to avoid modification
    }

    public int getTotalEnemyInGroup(int waveIndex, int groupIndex) {
        return Arrays.stream(waveDecomposition.get(waveIndex).get(groupIndex)).sum(); // Return the total number of enemies in the specified group
    }

    public int getTotalEnemyInWave(int waveIndex) {
        return IntStream.range(0, waveDecomposition.get(waveIndex).size())
                .map(i -> getTotalEnemyInGroup(waveIndex, i)).sum(); // Return the total number of enemies in the specified wave
    }
}
package com.kurabiye.kutd.model.Listeners;

public interface IGameUpdateListener {

    /*
     *  This interface is used to listen for game updates.
     *  The given float parameter is deltaTime multiplied by the Time Coefficient.
     *
     */

    void onGameUpdate(double deltaTime); // Method to be called on game update with delta time as parameter
    // This method will be implemented by classes that want to listen for game updates

}
package com.kurabiye.kutd.model.Player;

import java.io.Serializable;

import java.util.ArrayList;

/* This is the class where the defined game settings on the settings screen are stored.
 * It is used to set the game settings such as waves, speed, sound, music, and difficulty level etc.
 * 
 * It uses the Singleton pattern to ensure there's only one instance of user preferences
 * throughout the application, while keeping the Builder pattern for configuration.
 * 
 * This class is supposed to be serialized and deserialized to/from a file.
 * 
 * @author: Atlas Berk Polat
 * @version: 1.0
 * @since: 2025-04-23
 * 
 */
public class UserPreference implements Serializable {

    // Using volatile to ensure visibility across threads
    private static volatile UserPreference instance; // Singleton instance of UserPreference
    private static final long serialVersionUID = 1L; // Serial version UID for serialization

    // Game settings fields
    private String userName; // Player's name
    private float musicVolume; // Music volume level
    private float soundVolume; // Sound volume level
    private ArrayList<ArrayList<int[]>> waveList; // Number of groups per wave
    private int delayBetweenWaves; // Delay between waves in milliseconds
    private int delayBetweenGroups; // Delay between groups in milliseconds
    private int startingGold; // Starting amount of gold for the player
    private int[] goldPerEnemy; // Amount of gold earned when defeating an enemy
    private int startingHealth; // Starting hit points of the player
    private int[] enemyHealth; // Health points for each type of enemy
    
   
    private float artilleryRange; // Special range for artillery towers
    private int[] enemyMovementSpeed; // Movement speed for each enemy type
    private float[] towerSellReturn; // Percentage of cost returned when selling a tower

    // There should be certain changes in the certain fields for tower upgrades

    // The first index is the tower type, and the second index is the level of the tower
    // For example, towerEffectiveRange[0][1] is the effective range of tower type 0 at level 1
     private float[][] damageDealt; // Damage dealt by each tower type to each enemy type
     private float[][] towerEffectiveRange; // Effective range for each tower type
     private float[][] towerRateOfFire; // Rate of fire for each tower type
     private int[][] towerConstructionCost; // Cost to construct each tower type

    // Private constructor to enforce the singleton pattern
    private UserPreference() {
        // Initialize with default values
        initializeDefaultValues();
    }

    // Initialize default values for all settings
    private void initializeDefaultValues() {
        userName = "Player";
        musicVolume = 0.5f;
        soundVolume = 0.5f;
       
        delayBetweenWaves = 8; // 5 seconds
        delayBetweenGroups = 4; // 3 seconds

        waveList = new ArrayList<>(); // Initialize with an empty list
        ArrayList<int[]> wave1 = new ArrayList<>();
        wave1.add(new int[]{2,0}); // Example wave with different enemy types
        wave1.add(new int[]{3,0}); // Example group with different enemy types
        waveList.add(wave1); // Add the first wave to the list
        ArrayList<int[]> wave2 = new ArrayList<>();
        wave2.add(new int[]{2,1}); // Example wave with different enemy types
        wave2.add(new int[]{3,1}); // Example group with different enemy types
        waveList.add(wave2); // Add the second wave to the list
    
        startingGold = 100;
        goldPerEnemy = new int[]{15, 20}; // Gold earned per enemy type
        startingHealth = 5;
        enemyHealth = new int[]{50, 75}; // Health for each enemy type
        damageDealt = new float[][]{
            //Enemy0 Enemy1
            {5.0f, 1.0f}, // Damage for artillery type 0
            {7.0f, 15.0f}, // Damage for artillery type 1
            {8.0f, 7.0f}  // Damage for artillery type 2
        };
        towerConstructionCost = new int[][]{{50, 75, 100},{50, 75, 100}}; // Cost for each tower type
        towerEffectiveRange = new float[][]{{300.0f, 300.0f, 200.0f},{300.0f, 300.0f, 200.0f}}; // Range for each tower type
        towerRateOfFire = new float[][]{{0.5f, 1f, 5f},{0.5f, 1f, 5f}}; // Attack speed for each tower type
        artilleryRange = 3.0f; // Special long range for artillery
        enemyMovementSpeed = new int[]{60, 35}; // Movement speed for each enemy type
        towerSellReturn = new float[]{0.5f, 0.6f, 0.7f}; // Percentage returned when selling
    }

    /**
     * Thread-safe singleton implementation using double-checked locking
     * @return the singleton instance of UserPreference
     */
    public static UserPreference getInstance() {
        // First check (no locking)
        if (instance == null) {
            // Lock for thread safety
            synchronized (UserPreference.class) {
                // Second check (with locking)
                if (instance == null) {
                    instance = new UserPreference(); // Create a new instance if it doesn't exist
                }
            }
        }
        return instance; // Return the singleton instance
    }

    /**
     * Resets the singleton instance (useful for testing or when loading new preferences)
     */
    public static synchronized void resetInstance() {
        instance = null;
    }

    /**
     * Applies settings from a Builder to the singleton instance
     * @param builder the builder with configured settings
     */
    public static synchronized void applySettings(Builder builder) {
        instance = builder.build(); // Apply the new settings
    }

    // Getters for all fields - thread-safe by being effectively immutable after construction

    public static long getSerialVersionUID() {
        return serialVersionUID;
    }

    public String getUserName() {
        return userName;
    }

    public float getMusicVolume() {
        return musicVolume;
    }
    
    public float getSoundVolume() {
        return soundVolume;
    }
    
   
    
    
    
    public int getDelayBetweenWaves() {
        return delayBetweenWaves;
    }
    
    public int getDelayBetweenGroups() {
        return delayBetweenGroups;
    }
    
    public ArrayList<ArrayList<int[]>> getWaveList() {
        // Return a deep copy to maintain immutability
        if (waveList == null) {
            return null;
        }
        
        ArrayList<ArrayList<int[]>> copyList = new ArrayList<>();
        for (ArrayList<int[]> wave : waveList) {
            ArrayList<int[]> copyWave = new ArrayList<>();
            for (int[] group : wave) {
                copyWave.add(group.clone());
            }
            copyList.add(copyWave);
        }
        return copyList;
    }
    
    public int getStartingGold() {
        return startingGold;
    }
    
    public int[] getGoldPerEnemy() {
        return goldPerEnemy; 
    }
    
    public int getStartingHealth() {
        return startingHealth;
    }
    
    public int[] getEnemyHealth() {
        return enemyHealth; 
    }
    
    public float[][] getDamageDealt() {
        // Deep copy to maintain immutability
        float[][] copy = new float[damageDealt.length][];
        for (int i = 0; i < damageDealt.length; i++) {
            copy[i] = damageDealt[i].clone();
        }
        return copy;
    }
    
    public int[][] getTowerConstructionCost() {
        return towerConstructionCost.clone(); // Return a copy to maintain immutability
    }
    
    public float[][] getTowerEffectiveRange() {
        return towerEffectiveRange.clone(); // Return a copy to maintain immutability
    }
    
    public float[][] getTowerRateOfFire() {
        return towerRateOfFire.clone(); // Return a copy to maintain immutability
    }
    
    public float getArtilleryRange() {
        return artilleryRange;
    }
    
    public int[] getEnemyMovementSpeed() {
        return enemyMovementSpeed.clone(); // Return a copy to maintain immutability
    }
    
    public float[] getTowerSellReturn() {
        return towerSellReturn.clone(); // Return a copy to maintain immutability
    }

    // Builder class for constructing UserPreference instances in a fluent manner
    public static class Builder {
        private UserPreference userPreference;

        public Builder() {
            this.userPreference = new UserPreference();
        }

        /* This constructor is used to create a Builder object from an existing UserPreference object.
         * This is useful when you want to modify an existing UserPreference object using the Builder pattern.
         */
        public Builder(UserPreference userPreference) {
            this.userPreference = new UserPreference();
            
            // Copy all fields from the existing preferences
            if (userPreference != null) {
                this.userPreference.userName = userPreference.userName;
                this.userPreference.musicVolume = userPreference.musicVolume;
                this.userPreference.soundVolume = userPreference.soundVolume;
                
                
                this.userPreference.delayBetweenWaves = userPreference.delayBetweenWaves;
                this.userPreference.delayBetweenGroups = userPreference.delayBetweenGroups;
                
                // Copy waveList with deep copy to maintain immutability
                if (userPreference.waveList != null) {
                    this.userPreference.waveList = new ArrayList<>();
                    for (ArrayList<int[]> wave : userPreference.waveList) {
                        ArrayList<int[]> copyWave = new ArrayList<>();
                        for (int[] group : wave) {
                            copyWave.add(group.clone());
                        }
                        this.userPreference.waveList.add(copyWave);
                    }
                }
                
                this.userPreference.startingGold = userPreference.startingGold;
                
                if (userPreference.goldPerEnemy != null) {
                    this.userPreference.goldPerEnemy = userPreference.goldPerEnemy.clone();
                }
                
                this.userPreference.startingHealth = userPreference.startingHealth;
                
                if (userPreference.enemyHealth != null) {
                    this.userPreference.enemyHealth = userPreference.enemyHealth.clone();
                }
                
                if (userPreference.damageDealt != null) {
                    this.userPreference.damageDealt = new float[userPreference.damageDealt.length][];
                    for (int i = 0; i < userPreference.damageDealt.length; i++) {
                        this.userPreference.damageDealt[i] = userPreference.damageDealt[i].clone();
                    }
                }
                
                if (userPreference.towerConstructionCost != null) {
                    this.userPreference.towerConstructionCost = userPreference.towerConstructionCost.clone();
                }
                
                if (userPreference.towerEffectiveRange != null) {
                    this.userPreference.towerEffectiveRange = userPreference.towerEffectiveRange.clone();
                }
                
                if (userPreference.towerRateOfFire != null) {
                    this.userPreference.towerRateOfFire = userPreference.towerRateOfFire.clone();
                }
                
                this.userPreference.artilleryRange = userPreference.artilleryRange;
                
                if (userPreference.enemyMovementSpeed != null) {
                    this.userPreference.enemyMovementSpeed = userPreference.enemyMovementSpeed.clone();
                }
                
                if (userPreference.towerSellReturn != null) {
                    this.userPreference.towerSellReturn = userPreference.towerSellReturn.clone();
                }
            }
        }

        // Builder setter methods - each returns this Builder instance for method chaining

        public Builder setUserName(String userName) {
            userPreference.userName = userName;
            return this;
        }

        public Builder setMusicVolume(float musicVolume) {
            userPreference.musicVolume = musicVolume;
            return this;
        }

        public Builder setSoundVolume(float soundVolume) {
            userPreference.soundVolume = soundVolume;
            return this;
        }

       

        public Builder setDelayBetweenWaves(int delayBetweenWaves) {
            userPreference.delayBetweenWaves = delayBetweenWaves;
            return this;
        }

        public Builder setDelayBetweenGroups(int delayBetweenGroups) {
            userPreference.delayBetweenGroups = delayBetweenGroups;
            return this;
        }

        
        public Builder setStartingGold(int startingGold) {
            userPreference.startingGold = startingGold;
            return this;
        }

        public Builder setGoldPerEnemy(int[] goldPerEnemy) {
            userPreference.goldPerEnemy = goldPerEnemy;
            return this;
        }

        public Builder setStartingHealth(int startingHealth) {
            userPreference.startingHealth = startingHealth;
            return this;
        }

        public Builder setEnemyHealth(int[] enemyHealth) {
            userPreference.enemyHealth = enemyHealth;
            return this;
        }

        public Builder setDamageDealt(float[][] damageDealt) {
            userPreference.damageDealt = damageDealt;
            return this;
        }

        public Builder setTowerConstructionCost(int[][] towerConstructionCost) {
            userPreference.towerConstructionCost = towerConstructionCost;
            return this;
        }

        public Builder setTowerEffectiveRange(float[][] towerEffectiveRange) {
            userPreference.towerEffectiveRange = towerEffectiveRange;
            return this;
        }

        public Builder setTowerRateOfFire(float[][] towerRateOfFire) {
            userPreference.towerRateOfFire = towerRateOfFire;
            return this;
        }
        
        public Builder setWaveList(ArrayList<ArrayList<int[]>> waveList) {
            // Create a deep copy to ensure immutability
            if (waveList == null) {
                userPreference.waveList = null;
            } else {
                userPreference.waveList = new ArrayList<>();
                for (ArrayList<int[]> wave : waveList) {
                    ArrayList<int[]> copyWave = new ArrayList<>();
                    for (int[] group : wave) {
                        copyWave.add(group.clone());
                    }
                    userPreference.waveList.add(copyWave);
                }
            }
            return this;
        }
        
        public Builder setArtilleryRange(float artilleryRange) {
            userPreference.artilleryRange = artilleryRange;
            return this;
        }
        
        public Builder setEnemyMovementSpeed(int[] enemyMovementSpeed) {
            userPreference.enemyMovementSpeed = enemyMovementSpeed;
            return this;
        }
        
        public Builder setTowerSellReturn(float[] towerSellReturn) {
            userPreference.towerSellReturn = towerSellReturn;
            return this;
        }
        
        public UserPreference build() {
            return userPreference;
        }
    }
}
package com.kurabiye.kutd.model.Player;

import java.util.ArrayList;

import com.kurabiye.kutd.util.ObserverPattern.Observable;
import com.kurabiye.kutd.util.ObserverPattern.Observer;

/* This class represents a player in the game.
 * It gets the user preferences from the UserPreferences class and sets the player name, score, level, health, and gold.
 * 
 * 
 * 
 * 
 */

public class Player implements Observable{

    public enum PlayerState {
        ALIVE,
        DEAD
    }
    private PlayerState playerState = PlayerState.ALIVE; // Player's alive status

    
    private int currentScore; // Player's score
    private int currentGold; // Player's gold
    private int currentHealth; // Player's health

    private UserPreference userPreferences; // User preferences object

    public Player(UserPreference userPreferences) {
        this.userPreferences = userPreferences; // Initialize user preferences
        this.currentGold = this.userPreferences.getStartingGold(); // Set player's gold from user preferences
        this.currentHealth = this.userPreferences.getStartingHealth(); // Set player's health from user preferences
        this.currentScore = 0; // Initialize player's score to 0
    }

    public synchronized boolean buyTower(int cost) {
        if (currentGold >= cost) { // Check if player has enough gold
            currentGold -= cost; // Deduct cost from player's gold
            // Notify observers of gold change
            notifyObservers(currentGold);
            return true; // Purchase successful
        }
        return false; // Purchase failed due to insufficient gold
    }
    public synchronized void earnGold(int amount) {
        currentGold += amount; // Add gold to player's total
        notifyObservers(this);
    }

    public synchronized void sellTower(int cost) {
        currentGold += cost; // Add cost to player's total gold
        notifyObservers(this);
    }
    /*
     * This method is used to deduct health from the player when they take damage.
     * @return true if the player is still alive, false if the player is dead.
     * This method is synchronized to ensure thread safety when modifying the player's health.
     */
    public synchronized void loseHealth() {
        currentHealth --; // Deduct damage from player's health
        if (currentHealth <= 0) {
            playerState = PlayerState.DEAD; // Set player state to dead
        }
        notifyObservers(this); // Notify observers of health change
    }

    public synchronized int getCurrentScore() {
        return currentScore; // Get player's score
    }
    
    public synchronized int getCurrentGold() {
        return currentGold; // Get player's gold
    }
    
    public synchronized int getCurrentHealth() {
        return currentHealth; // Get player's health
    }
    
    public synchronized void earnScore(int amount) {
        currentScore += amount; // Add score to player's total
        notifyObservers(this); // Notify observers of score change
    }

    public synchronized PlayerState getPlayerState() {
        return playerState; // Get player's state
    }


    /// Observer Pattern Methods
    /// 
    /// These methods are used to implement the Observer pattern, allowing other objects to observe changes in the Player's state.
    
    ArrayList<Observer> observers = new ArrayList<>(); // List of observers

    @Override
    public void addObserver(Observer observer) {
        observers.add(observer); // Add an observer to the list
    }

    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer); // Remove an observer from the list
    }

    @Override
    public void notifyObservers(Object arg) {
        for (Observer observer : observers) {
            observer.update(this); // Notify each observer with the current Player object and argument
        }
    }

    

    

}
package com.kurabiye.kutd.view;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;
import javafx.scene.canvas.Canvas;

public class MapEditorViewTest {
    private MapEditorView mapEditor;
    private Canvas canvas;

    @BeforeEach
    void setUp() {
        mapEditor = new MapEditorView();
        // Initialize necessary components
        canvas = new Canvas(MapEditorView.COLS * MapEditorView.TILE_SIZE,
                MapEditorView.ROWS * MapEditorView.TILE_SIZE);
        mapEditor.canvas = canvas;
        mapEditor.gc = canvas.getGraphicsContext2D();
        mapEditor.initializeMapData();
    }

    @Test
    void testHandleMapClick_ValidCoordinates_UpdatesTile() {
        // Set a specific tile type to place
        mapEditor.selectedTileType = 15; // Buildable tile

        // Click at column 5, row 3 (middle of the canvas)
        double x = 5 * MapEditorView.TILE_SIZE + 10; // 10 pixels into the tile
        double y = 3 * MapEditorView.TILE_SIZE + 10;

        mapEditor.handleMapClick(x, y);

        // Verify the tile was updated
        assertEquals(15, mapEditor.mapData[3][5],
                "Tile at clicked position should be updated to selected tile type");
    }

    @Test
    void testHandleMapClick_EdgeCoordinates_UpdatesTile() {
        // Set a different tile type
        mapEditor.selectedTileType = 0; // Path start tile

        // Click at the very edge of the canvas (last column, first row)
        double x = (MapEditorView.COLS - 1) * MapEditorView.TILE_SIZE;
        double y = 0;

        mapEditor.handleMapClick(x, y);

        // Verify the tile was updated
        assertEquals(0, mapEditor.mapData[0][MapEditorView.COLS - 1],
                "Edge tile should be updated to selected tile type");
    }

    @Test
    void testHandleMapClick_OutsideCanvas_NoUpdate() {
        // Store original map data
        int[][] originalMap = new int[MapEditorView.ROWS][MapEditorView.COLS];
        for (int i = 0; i < MapEditorView.ROWS; i++) {
            System.arraycopy(mapEditor.mapData[i], 0, originalMap[i], 0, MapEditorView.COLS);
        }

        // Click outside the canvas (negative coordinates)
        mapEditor.handleMapClick(-10, -10);

        // Click outside the canvas (beyond width/height)
        mapEditor.handleMapClick(MapEditorView.COLS * MapEditorView.TILE_SIZE + 10,
                MapEditorView.ROWS * MapEditorView.TILE_SIZE + 10);

        // Verify no tiles were changed
        assertArrayEquals(originalMap, mapEditor.mapData,
                "Map data should remain unchanged when clicking outside canvas");
    }

    @Test
    void testHandleMapClick_DragOperation_UpdatesMultipleTiles() {
        mapEditor.selectedTileType = 5; // Ground tile

        // Simulate drag from (2,2) to (4,4)
        mapEditor.handleMapClick(2 * MapEditorView.TILE_SIZE + 5, 2 * MapEditorView.TILE_SIZE + 5);
        mapEditor.handleMapClick(3 * MapEditorView.TILE_SIZE + 5, 3 * MapEditorView.TILE_SIZE + 5);
        mapEditor.handleMapClick(4 * MapEditorView.TILE_SIZE + 5, 4 * MapEditorView.TILE_SIZE + 5);

        // Verify all dragged-over tiles were updated
        assertEquals(5, mapEditor.mapData[2][2], "Tile (2,2) should be updated");
        assertEquals(5, mapEditor.mapData[3][3], "Tile (3,3) should be updated");
        assertEquals(5, mapEditor.mapData[4][4], "Tile (4,4) should be updated");

    }
}package com.kurabiye.kutd.view;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ViewTest {
  
    @Test
    public void testViewInitialization() {
        // Basic test to verify the class can be initialized
        View view = new View();
        assertNotNull(view);
    }
    
}
package com.kurabiye.kutd.view;

import javafx.scene.canvas.GraphicsContext;
import javafx.scene.image.Image;


import com.kurabiye.kutd.model.Coordinates.*;
import java.util.ArrayList;

import com.kurabiye.kutd.model.Enemy.EnemyType;
import com.kurabiye.kutd.model.Enemy.IEnemy;
import com.kurabiye.kutd.model.Enemy.Enemy;

import com.kurabiye.kutd.model.Player.UserPreference;

/**
 * EnemyView class for rendering enemies on the game canvas.
 * This class is responsible for visualizing enemies and their animations.
 */
public class EnemyView {
    private final int TILE_SIZE;
    private final int COLS = 16; // Number of columns in the game map
   // private final int ROWS = 9; // Number of rows in the game map
    
    // Different enemy images for different enemy types
    private Image[] enemyImages;
    
    public EnemyView(int tileSize) {
        this.TILE_SIZE = tileSize;
        loadEnemyImages();
    }
    
    /**
     * Load enemy sprite images from resources
     */
    private void loadEnemyImages() {
        // We need images for each enemy type from the enum
        enemyImages = new Image[EnemyType.values().length * 6];
        
        for (EnemyType type : EnemyType.values()) {
            for (int i = 0; i < 6; i++) {
                String imagePath = String.format("/assets/enemies/%s%d.png", type.name().toLowerCase(), i);
                try {
                    enemyImages[type.getValue() * 6 + i] = new Image(getClass().getResourceAsStream(imagePath));
                } catch (Exception e) {
                    // If the image cannot be loaded, create a fallback image
                    enemyImages[type.getValue() * 6 + i] = createFallbackImage(type);
                }
            }
        }
    }

    /**
     * Create a fallback image if the enemy sprite cannot be loaded
     */
    private Image createFallbackImage(EnemyType type) {
        // Create a simple colored circle as fallback
        javafx.scene.canvas.Canvas canvas = new javafx.scene.canvas.Canvas(TILE_SIZE, TILE_SIZE);
        GraphicsContext gc = canvas.getGraphicsContext2D();
        
        // Different colors for different enemy types
        switch (type) {
            case GOBLIN:
                gc.setFill(javafx.scene.paint.Color.GREEN);
                break;
            case KNIGHT:
                gc.setFill(javafx.scene.paint.Color.GRAY);
                break;
            default:
                gc.setFill(javafx.scene.paint.Color.RED);
        }
        
        // Draw a circle
        gc.fillOval(4, 4, TILE_SIZE - 8, TILE_SIZE - 8);
        
        // Convert canvas to image
        return canvas.snapshot(null, null);
    }
 
    /**
     * Render all enemies on the canvas
     * @param gc GraphicsContext to draw on
     * @param enemies List of enemies to render
     */
    public void renderEnemies(GraphicsContext gc, ArrayList<IEnemy> enemies, int enemyImage) {
        for (IEnemy enemy : enemies) {
            renderEnemy(gc, enemy, enemyImage);
        }
    }
    
    /**
     * Render a single enemy on the canvas
     * @param gc GraphicsContext to draw on
     * @param enemy Enemy to render
     */
    private void renderEnemy(GraphicsContext gc, IEnemy enemy, int enemyImage) {
        // Skip rendering dead enemies or those that have arrived at destination
        if (enemy.isDead() || enemy.hasArrived()) {
            return;
        }
        
        // Get the enemy's current position
        Point2D position = enemy.getCoordinate();
        
        // Transform model coordinates to view coordinates
        double modelWidth = 1920;  // The width used in the model
        //double modelHeight = 1080; // The height used in the model
        double scaleFactor = TILE_SIZE * COLS / modelWidth; // Calculate the scale factor
        
        // Scale positions from model space to view space
        double viewX = position.getX() * scaleFactor;
        double viewY = position.getY() * scaleFactor;
        
        // Center the enemy image on the path point by offsetting half the tile size
        double centeredX = viewX - (TILE_SIZE / 2);
        double centeredY = viewY - (TILE_SIZE / 2);
        
        // Determine which image to use based on enemy type
        EnemyType enemyType = enemy.getEnemyType();
        int imageEIndex = enemyType.getValue();
        
        // If the image is loaded successfully
        if (enemyImages[imageEIndex * 6 + enemyImage] != null) {
            // Atlas:
            // Draw the enemy image
            // According to the enemy speed vector, we can determine the direction
            // and image reflection might be needed
            // I will use dot product to determine the direction

            enemy.getMoveDirection().dotProduct(new Point2D(1, 0));
            if (enemy.getMoveDirection().dotProduct(new Point2D(1, 0)) < 0) {
                // Flip the image horizontally
                gc.scale(-1, 1);
                gc.drawImage(enemyImages[enemyType.getValue() * 6 + enemyImage], -centeredX - TILE_SIZE, centeredY, TILE_SIZE, TILE_SIZE);
                gc.scale(-1, 1); // Reset scale
            } else {
                // Draw normally
                gc.drawImage(enemyImages[enemyType.getValue() * 6 + enemyImage], centeredX, centeredY, TILE_SIZE, TILE_SIZE);
            }

           
            
            // Draw health bar above the enemy
            renderHealthBar(gc, enemy, viewX - TILE_SIZE/2, viewY - TILE_SIZE/2);
        }
    }
    
    /**
     * Render health bar above the enemy
     * @param gc GraphicsContext to draw on
     * @param enemy Enemy whose health to display
     * @param x X coordinate of the enemy
     * @param y Y coordinate of the enemy
     */
    private void renderHealthBar(GraphicsContext gc, IEnemy enemy, double x, double y) {
        // We need to find maximum health for the enemy type from user preferences
        // For now, let's use the current health as relative value
        float currentHealth = enemy.getHealth();
        
        // Get the initial health for this enemy type from user preferences
        UserPreference prefs = UserPreference.getInstance();
        int maxHealth = prefs.getEnemyHealth()[enemy.getEnemyType().getValue()];
        
        // Calculate health percentage
        double healthPercentage = currentHealth / maxHealth;
        
        x = x + TILE_SIZE / 4; // Center the health bar above the enemy

        // Bar dimensions
        double barWidth = TILE_SIZE / 2;
        double barHeight = 5;
        double barY = y + 10; // Position above the enemy
        
        // Draw background (empty health)
        gc.setFill(javafx.scene.paint.Color.RED);
        gc.fillRect(x, barY, barWidth, barHeight);
        
        // Draw filled health
        gc.setFill(javafx.scene.paint.Color.GREEN);
        gc.fillRect(x, barY, barWidth * healthPercentage, barHeight);
    }
}// package com.kurabiye.kutd.view;

// import com.kurabiye.kutd.model.Tower.Tower;
// import com.kurabiye.kutd.model.Projectile.Projectile.ProjectileType;
// import javafx.scene.canvas.GraphicsContext;
// import javafx.scene.image.Image;

// import java.util.ArrayList;

// public class TowerView {
//     private static final int TOWER_IMAGE_COUNT = 3;
//     private final Image[] towerImages = new Image[TOWER_IMAGE_COUNT];
//     private final int tileSize;
    
//     public TowerView(int tileSize) {
//         this.tileSize = tileSize;
//         loadTowerImages();
//     }
    
//     private void loadTowerImages() {
//         // Load tower images based on their projectile type
//         towerImages[ProjectileType.ARROW.getValue()] = new Image(getClass().getResourceAsStream("/assets/tiles/tile26.png"));
//         towerImages[ProjectileType.MAGIC.getValue()] = new Image(getClass().getResourceAsStream("/assets/tiles/tile21.png"));
//         towerImages[ProjectileType.ARTILLERY.getValue()] = new Image(getClass().getResourceAsStream("/assets/tiles/tile20.png"));
//     }
    
//     public void renderTowers(GraphicsContext gc, ArrayList<Tower> towers) {
//         if (towers == null || towers.isEmpty()) {
//             return;
//         }
        
//         for (Tower tower : towers) {
//             // Get the projectile type to determine which image to use
//             ProjectileType projectileType = tower.getProjectileType();
            
//             // Get tower position
//             int col = tower.getTileCoordinate().getTileX();
//             int row = tower.getTileCoordinate().getTileY();
            
//             // Draw the tower at its position
//             gc.drawImage(towerImages[projectileType.getValue()], 
//                         col * tileSize, 
//                         row * tileSize, 
//                         tileSize, 
//                         tileSize);
//         }
//     }
// }package com.kurabiye.kutd.view.Animation;

import javafx.scene.canvas.GraphicsContext;
import javafx.scene.image.Image;

/* Sprite.java
 * This class is responsible for handling the sprite animations in the game. 
 * It takes an image and splits it into frames for animation.
 * The class provides methods to update the current frame and render the sprite on the screen.
 * 
 * 
 * @author Atlas Berk Polat
 * @version 1.0
 * @since 2025-05-04
 * 
 */

public class Sprite {


    GraphicsContext gc; // Graphics context for rendering the sprite



    private Image[] frames; // Array of frames for the sprite animation


    private double currentTime; // Time duration for each frame

    private double desiredAnimationLength; // Desired length of the animation in frames

    private double desiredTotalLength; // Total length of the animation in frames

    private int positionX; // X position of the sprite on the screen
    private int positionY; // Y position of the sprite on the screen
    private int width; // Width of the sprite
    private int height; // Height of the sprite



    public Sprite(GraphicsContext gc, Image image, double desiredAnimationLength, double desiredTotalLength, int positionX, int positionY, int width, int height) {
        this.gc = gc; // Initialize the graphics context
       
        this.desiredAnimationLength = desiredAnimationLength; // Calculate the desired animation length

        this.desiredTotalLength = desiredTotalLength; // Calculate the total length of the animation
        this.positionX = positionX; // Set the X position of the sprite
        this.positionY = positionY; // Set the Y position of the sprite
        this.width = width; // Set the width of the sprite
        this.height = height; // Set the height of the sprite
        currentTime = 0; // Initialize the current time to 0

        // Split the image into frames

        // divide the length of the image to the height of the image to get the number of frames

        int frameCount = (int) (image.getWidth() / image.getHeight()); // Calculate the number of frames
        frames = new Image[frameCount]; // Initialize the frames array

        for (int i = 0; i < frameCount; i++) {
            frames[i] = new Image(image.getUrl(), image.getWidth() / frameCount, image.getHeight(), false, false); // Create a new image for each frame
        }

        // render the first frame

        this.update(0, this.positionX, this.positionY); // Render the first frame on the screen
    }



    public void update(double deltaTime, int coordinateX, int coordinateY) {
        currentTime += deltaTime; // Update the current time

        if (currentTime >= desiredTotalLength) { // If the total animation is complete
            return;
            
        }

        int repetation = (int) (currentTime / desiredAnimationLength); // Calculate the number of repetitions

        double remainingTime = (currentTime - repetation *  desiredAnimationLength); // Calculate the remaining time

        int currentFrame = (int) (((remainingTime % desiredAnimationLength) / desiredAnimationLength) * frames.length) ; // Calculate the current frame


        // Render the current frame

        gc.drawImage(frames[currentFrame], coordinateX - width / 2, coordinateY - height / 2, width, height); // Draw the current frame on the canvas

        
    }


}
package com.kurabiye.kutd.view;

import com.kurabiye.kutd.controller.GamePlayController;
import com.kurabiye.kutd.controller.MainMenuController;
import com.kurabiye.kutd.controller.SettingsController;

import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.effect.DropShadow;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class MainMenuView {

    private MainMenuController controller = new MainMenuController();

    public void start(Stage stage) {
        BorderPane root = new BorderPane();

        // Load background image
        Image backgroundImage = new Image(getClass().getClassLoader().getResource("assets/background.jpeg").toExternalForm());
        ImageView backgroundView = new ImageView(backgroundImage);
        backgroundView.setFitWidth(600);
        backgroundView.setFitHeight(400);
        backgroundView.setPreserveRatio(false); // Fill the entire scene

        // Game title with shadow
        Text titleText = new Text("KU TOWER DEFENSE");
        titleText.setFont(Font.font("System", FontWeight.BOLD, 48));
        titleText.setFill(Color.GOLD);

        DropShadow dropShadow = new DropShadow();
        dropShadow.setColor(Color.BLACK);
        dropShadow.setRadius(5.0);
        dropShadow.setOffsetX(2.0);
        dropShadow.setOffsetY(2.0);
        titleText.setEffect(dropShadow);

        // Create buttons
        Button playButton = createMenuButton("Play Game");
        Button mapEditorButton = createMenuButton("Map Editor"); // New Map Editor button
        Button settingsButton = createMenuButton("Settings");
        Button exitButton = createMenuButton("Exit");

        // Layout for title and buttons
        VBox vbox = new VBox(20);
        vbox.setAlignment(Pos.CENTER);
        vbox.getChildren().addAll(titleText, playButton, mapEditorButton, settingsButton, exitButton);

        StackPane mainPane = new StackPane();
        mainPane.getChildren().addAll(backgroundView, vbox);

        root.setCenter(mainPane);

        Scene scene = new Scene(root, 600, 400);
        stage.setTitle("Tower Defense - Main Menu");
        stage.setScene(scene);
        stage.show();

        // Button actions (you can fill these later)
        playButton.setOnAction(e -> {
            // TODO: Start the game

            GamePlayController gamePlayController = controller.onPlayButtonPressed();
            GamePlayView mapView = new GamePlayView();
            mapView.start(stage, gamePlayController);
        });

        mapEditorButton.setOnAction(e -> {
            // TODO: Open Map Editor
            MapEditorView mapEditor = new MapEditorView();
            mapEditor.start(stage);
        });

        settingsButton.setOnAction(e -> {
            
            SettingsController settingsController = controller.onSettingsButtonPressed();
            SettingsView settingsView = new SettingsView();
            settingsView.show(stage, settingsController);
        });

        exitButton.setOnAction(e -> {
            stage.close();
        });
    }

    private Button createMenuButton(String text) {
        Button button = new Button(text);
        button.setPrefWidth(200);
        button.setPrefHeight(40);
        button.setStyle(
            "-fx-background-color: linear-gradient(to bottom right, #4CAF50, #2E7D32);" +
            "-fx-text-fill: white;" +
            "-fx-font-size: 16px;" +
            "-fx-background-radius: 10;"
        );

        button.setOnMouseEntered(e -> button.setStyle(
            "-fx-background-color: linear-gradient(to bottom right, #66BB6A, #388E3C);" +
            "-fx-text-fill: white;" +
            "-fx-font-size: 16px;" +
            "-fx-background-radius: 10;"
        ));

        button.setOnMouseExited(e -> button.setStyle(
            "-fx-background-color: linear-gradient(to bottom right, #4CAF50, #2E7D32);" +
            "-fx-text-fill: white;" +
            "-fx-font-size: 16px;" +
            "-fx-background-radius: 10;"
        ));

        return button;
    }
}
package com.kurabiye.kutd.view;

import com.kurabiye.kutd.controller.SettingsController;
import com.kurabiye.kutd.model.Player.UserPreference;

import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.effect.DropShadow;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.Stage;

import java.util.Random;

public class SettingsView {

    public void show(Stage stage, SettingsController controller) {
        // Create a new stage for settings
        Stage settingsStage = new Stage();
        
        // Current preference values
        UserPreference current = controller.getCurrentPreferences();

        // Create main layout
        BorderPane root = new BorderPane();
        
   
        try {
            Image backgroundImage = new Image(getClass().getClassLoader().getResource("assets/castle_loadingbg.png").toExternalForm());
            ImageView backgroundView = new ImageView(backgroundImage);
            backgroundView.setFitWidth(800);
            backgroundView.setFitHeight(600);
            backgroundView.setPreserveRatio(false); 
            
            // Add a semi-transparent overlay
            Region overlay = new Region();
            overlay.setPrefSize(800, 600);
            overlay.setStyle("-fx-background-color: rgba(0, 0, 0, 0.75);");

    
            
            // Stack background and overlay
            StackPane backgroundStack = new StackPane(backgroundView, overlay);
            root.setCenter(backgroundStack);
        } catch (Exception e) {
            // Fallback if image can't be loaded
            root.setStyle("-fx-background-color: #212121;"); 
        }
        
        // Create title
        Text titleText = new Text("GAME SETTINGS");
        titleText.setFont(Font.font("System", FontWeight.BOLD, 36));
        titleText.setFill(Color.GOLD);
        
        DropShadow dropShadow = new DropShadow();
        dropShadow.setColor(Color.BLACK);
        dropShadow.setRadius(5.0);
        dropShadow.setOffsetX(2.0);
        dropShadow.setOffsetY(2.0);
        titleText.setEffect(dropShadow);
        
        // Create settings panels
        VBox settingsContainer = new VBox(20);
        settingsContainer.setAlignment(Pos.TOP_CENTER);
        settingsContainer.setPadding(new Insets(30, 40, 30, 40));
        settingsContainer.getChildren().add(titleText);
        
        // Player settings
        VBox playerSettings = createSettingsPanel("PLAYER SETTINGS");
        
        TextField usernameField = new TextField(current.getUserName());
        styleTextField(usernameField);
        
        addLabelAndControl(playerSettings, "Commander Name:", usernameField);
        
        // Audio settings
        VBox audioSettings = createSettingsPanel("AUDIO SETTINGS");
        
        Slider musicVolumeSlider = new Slider(0, 1, current.getMusicVolume());
        styleSlider(musicVolumeSlider);
        
        Slider soundVolumeSlider = new Slider(0, 1, current.getSoundVolume());
        styleSlider(soundVolumeSlider);
        
        // Add volume percentage labels
        Label musicValueLabel = new Label(Math.round(current.getMusicVolume() * 100) + "%");
        styleValueLabel(musicValueLabel);
        
        Label soundValueLabel = new Label(Math.round(current.getSoundVolume() * 100) + "%");
        styleValueLabel(soundValueLabel);
        
        // Update labels when sliders change
        musicVolumeSlider.valueProperty().addListener((obs, oldVal, newVal) -> 
            musicValueLabel.setText(Math.round(newVal.doubleValue() * 100) + "%"));
            
        soundVolumeSlider.valueProperty().addListener((obs, oldVal, newVal) -> 
            soundValueLabel.setText(Math.round(newVal.doubleValue() * 100) + "%"));
        
        HBox musicBox = new HBox(10, musicVolumeSlider, musicValueLabel);
        musicBox.setAlignment(Pos.CENTER_LEFT);
        
        HBox soundBox = new HBox(10, soundVolumeSlider, soundValueLabel);
        soundBox.setAlignment(Pos.CENTER_LEFT);
        
        addLabelAndControl(audioSettings, "Music Volume:", musicBox);
        addLabelAndControl(audioSettings, "Sound Effects:", soundBox);
        
        // Game settings
        VBox gameSettings = createSettingsPanel("GAME SETTINGS");
        
        TextField delayBetweenWavesField = new TextField(String.valueOf(current.getDelayBetweenWaves()));
        styleTextField(delayBetweenWavesField);
        
        TextField delayBetweenGroupsField = new TextField(String.valueOf(current.getDelayBetweenGroups()));
        styleTextField(delayBetweenGroupsField);
        
        TextField startingGoldField = new TextField(String.valueOf(current.getStartingGold()));
        styleTextField(startingGoldField);
        
        TextField startingHealthField = new TextField(String.valueOf(current.getStartingHealth()));
        styleTextField(startingHealthField);
        
        TextField artilleryRangeField = new TextField(String.valueOf(current.getArtilleryRange()));
        styleTextField(artilleryRangeField);
        
        addLabelAndControl(gameSettings, "Delay Between Waves (ms):", delayBetweenWavesField);
        addLabelAndControl(gameSettings, "Delay Between Groups (ms):", delayBetweenGroupsField);
        addLabelAndControl(gameSettings, "Starting Gold:", startingGoldField);
        addLabelAndControl(gameSettings, "Starting Health:", startingHealthField);
        addLabelAndControl(gameSettings, "Artillery Range:", artilleryRangeField);
        
        // Add all settings panels to container
        settingsContainer.getChildren().addAll(playerSettings, audioSettings, gameSettings);
        
        // Create buttons with the same style as the loading screen
        Button applyButton = new Button("APPLY CHANGES");
        styleButton(applyButton);
        
        Button resetButton = new Button("RESET TO DEFAULTS");
        styleButton(resetButton);
        
        Button returnButton = new Button("RETURN TO MENU");
        styleButton(returnButton);
        returnButton.setPrefWidth(200);
        
        // Create button container
        HBox buttonBox = new HBox(20, applyButton, resetButton);
        buttonBox.setAlignment(Pos.CENTER);
        
        VBox returnBox = new VBox(20, returnButton);
        returnBox.setAlignment(Pos.CENTER);
        returnBox.setPadding(new Insets(10, 0, 20, 0));
        
        settingsContainer.getChildren().addAll(buttonBox, returnBox);
        
        
        // Stack all content
        StackPane contentStack = new StackPane();

        
        // Add a scroll pane for the settings
        ScrollPane scrollPane = new ScrollPane(settingsContainer);
        scrollPane.setFitToWidth(true);
        scrollPane.setStyle("-fx-background: transparent; -fx-background-color: transparent;");
        scrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        
        contentStack.getChildren().add(scrollPane);
        
        // Add content to the root
        ((StackPane)root.getCenter()).getChildren().add(contentStack);

        // Actions
        applyButton.setOnAction(e -> {
            try {
                UserPreference.Builder builder = new UserPreference.Builder()
                    .setUserName(usernameField.getText())
                    .setMusicVolume((float) musicVolumeSlider.getValue())
                    .setSoundVolume((float) soundVolumeSlider.getValue())
                    .setDelayBetweenWaves(Integer.parseInt(delayBetweenWavesField.getText()))
                    .setDelayBetweenGroups(Integer.parseInt(delayBetweenGroupsField.getText()))
                    .setStartingGold(Integer.parseInt(startingGoldField.getText()))
                    .setStartingHealth(Integer.parseInt(startingHealthField.getText()))
                    .setArtilleryRange(Float.parseFloat(artilleryRangeField.getText()));
        
                controller.applyPreferences(builder);
                showAlert("Preferences applied!");
            } catch (NumberFormatException ex) {
                showAlert("Invalid input: please enter numeric values where appropriate.");
            }
        });

        resetButton.setOnAction(e -> {
            controller.resetPreferencesToDefault();

            // Refresh UI with new default values
            UserPreference defaults = controller.getCurrentPreferences();
            usernameField.setText(defaults.getUserName());
            musicVolumeSlider.setValue(defaults.getMusicVolume());
            soundVolumeSlider.setValue(defaults.getSoundVolume());
            delayBetweenWavesField.setText(String.valueOf(defaults.getDelayBetweenWaves()));
            delayBetweenGroupsField.setText(String.valueOf(defaults.getDelayBetweenGroups()));
            startingGoldField.setText(String.valueOf(defaults.getStartingGold()));
            startingHealthField.setText(String.valueOf(defaults.getStartingHealth()));
            artilleryRangeField.setText(String.valueOf(defaults.getArtilleryRange()));

            // Update percentage labels
            musicValueLabel.setText(Math.round(defaults.getMusicVolume() * 100) + "%");
            soundValueLabel.setText(Math.round(defaults.getSoundVolume() * 100) + "%");

            showAlert("Preferences reset to defaults.");
        });
        
        returnButton.setOnAction(e -> {
            settingsStage.close();
            stage.show();
        });


        Scene scene = new Scene(root, 800, 600);
        settingsStage.setTitle("Tower Defense - Settings");
        settingsStage.setScene(scene);
        settingsStage.show();
        
        stage.hide();
    }
    
    private VBox createSettingsPanel(String title) {
        // Create panel title
        Label titleLabel = new Label(title);
        titleLabel.setFont(Font.font("System", FontWeight.BOLD, 18));
        titleLabel.setTextFill(Color.rgb(0, 218, 142)); 
        titleLabel.setPadding(new Insets(0, 0, 10, 0));
        
        // Create panel
        VBox panel = new VBox(12);
        panel.setStyle("-fx-background-color: rgba(20, 20, 20, 0.7); -fx-background-radius: 10;");
        panel.setPadding(new Insets(15, 20, 15, 20));
        panel.getChildren().add(titleLabel);
        
        return panel;
    }
    
    private void addLabelAndControl(VBox panel, String labelText, Control control) {
        Label label = new Label(labelText);
        label.setFont(Font.font("System", FontWeight.NORMAL, 14));
        label.setTextFill(Color.WHITE);
        
        panel.getChildren().addAll(label, control);
    }
    
    private void addLabelAndControl(VBox panel, String labelText, Pane controlContainer) {
        Label label = new Label(labelText);
        label.setFont(Font.font("System", FontWeight.NORMAL, 14));
        label.setTextFill(Color.WHITE);
        
        panel.getChildren().addAll(label, controlContainer);
    }
    
    private void styleTextField(TextField field) {
        field.setStyle(
            "-fx-background-color: rgba(30, 30, 30, 0.8);" +
            "-fx-text-fill: white;" +
            "-fx-border-color: rgb(0, 218, 142);" +
            "-fx-border-width: 1px;" +
            "-fx-border-radius: 5px;" +
            "-fx-background-radius: 5px;" +
            "-fx-padding: 8px;"
        );
        field.setPrefHeight(35);
    }
    
    private void styleSlider(Slider slider) {
        slider.setShowTickMarks(true);
        slider.setShowTickLabels(true);
        slider.setMajorTickUnit(0.25);
        slider.setMinorTickCount(5);
        slider.setBlockIncrement(0.1);
        slider.setPrefWidth(300);
        slider.setStyle(
            "-fx-control-inner-background: #3c3b3f;" +
            "-fx-accent: rgb(0, 218, 142);" 
        );
    }
    
    private void styleValueLabel(Label label) {
        label.setTextFill(Color.WHITE);
        label.setFont(Font.font("System", FontWeight.BOLD, 14));
        label.setMinWidth(50);
    }
    
    private void styleButton(Button button) {
        button.setPrefHeight(40);
        button.setPrefWidth(180);
        button.setFont(Font.font("System", FontWeight.BOLD, 14));
        
        button.setStyle(
            "-fx-background-color: rgb(0, 218, 142);" +
            "-fx-text-fill: white;" +
            "-fx-background-radius: 8px;" +
            "-fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.6), 5, 0, 0, 1);"
        );
        
        button.setOnMouseEntered(e -> button.setStyle(
            "-fx-background-color: rgb(34, 220, 155);" + 
            "-fx-text-fill: white;" +
            "-fx-background-radius: 8px;" +
            "-fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.8), 8, 0, 0, 1);"
        ));
        
        button.setOnMouseExited(e -> button.setStyle(
            "-fx-background-color: rgb(0, 218, 142);" +
            "-fx-text-fill: white;" +
            "-fx-background-radius: 8px;" +
            "-fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.6), 5, 0, 0, 1);"
        ));
        
        button.setOnMousePressed(e -> button.setStyle(
            "-fx-background-color: rgb(0, 190, 120);" +
            "-fx-text-fill: white;" +
            "-fx-background-radius: 8px;" +
            "-fx-translate-y: 2px;" +
            "-fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.4), 3, 0, 0, 1);"
        ));
        
        button.setOnMouseReleased(e -> button.setStyle(
            "-fx-background-color: rgb(0, 218, 142);" +
            "-fx-text-fill: white;" +
            "-fx-background-radius: 8px;" +
            "-fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.6), 5, 0, 0, 1);"
        ));
    }
    

    private void showAlert(String message) {
        Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setTitle("Settings");
        alert.setHeaderText(null);
        alert.setContentText(message);
        
        // Style the alert dialog
        DialogPane dialogPane = alert.getDialogPane();
        dialogPane.setStyle(
            "-fx-background-color: #212121;" +
            "-fx-text-fill: white;"
        );
        
        // Apply styles to the buttons in the alert
        dialogPane.lookupButton(ButtonType.OK).setStyle(
            "-fx-background-color: rgb(0, 218, 142);" +
            "-fx-text-fill: white;" +
            "-fx-background-radius: 5px;"
        );
        
        alert.showAndWait();
    }
}package com.kurabiye.kutd.view;

import javafx.scene.ImageCursor;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.stage.Screen;
import javafx.stage.Stage;
import javafx.scene.control.Button;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;

import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import com.kurabiye.kutd.controller.GamePlayController;
import com.kurabiye.kutd.model.Coordinates.Point2D;
import com.kurabiye.kutd.model.Enemy.Enemy;
import com.kurabiye.kutd.model.Enemy.IEnemy;
import com.kurabiye.kutd.model.Listeners.IGameUpdateListener;
import com.kurabiye.kutd.model.Managers.GameManager.GameState;
import com.kurabiye.kutd.model.Map.GameMap;
import com.kurabiye.kutd.model.Projectile.IProjectile;
import com.kurabiye.kutd.model.Projectile.Projectile;
import com.kurabiye.kutd.model.Projectile.Projectile.ProjectileType;
import com.kurabiye.kutd.util.ObserverPattern.Observer;
import com.kurabiye.kutd.model.Tower.ITower;
import com.kurabiye.kutd.model.Tower.Tower;

import javafx.animation.AnimationTimer;
import javafx.application.Platform;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.geometry.Rectangle2D;
import javafx.geometry.VPos;
import javafx.scene.input.MouseEvent;

public class GamePlayView implements IGameUpdateListener, Observer {
    
    // Reference dimensions that the game was designed for
    private static final int REFERENCE_WIDTH = 1920;
    private static final int REFERENCE_HEIGHT = 1080;
    
    // The actual screen dimensions
    private static final int SCREEN_WIDTH = (int) Screen.getPrimary().getBounds().getWidth();
    private static final int SCREEN_HEIGHT = (int) Screen.getPrimary().getBounds().getHeight();
    
    // Keep the map grid fixed at 16x9
    private static final int ROWS = 9;
    private static final int COLS = 16;
    
    // Calculate scaling factors
    private static final double SCALE_X = (double) SCREEN_WIDTH / REFERENCE_WIDTH;
    private static final double SCALE_Y = (double) SCREEN_HEIGHT / REFERENCE_HEIGHT;
    
    // Use the smaller scaling factor to maintain aspect ratio
    private static final double SCALE = Math.min(SCALE_X, SCALE_Y);
    
    // Calculate the tile size based on the scale
    private static final int TILE_SIZE = (int) (REFERENCE_WIDTH / COLS * SCALE);
    
    // Calculate the actual canvas size
    private static final int CANVAS_WIDTH = TILE_SIZE * COLS;
    private static final int CANVAS_HEIGHT = TILE_SIZE * ROWS;
    
    private static final int TILE_COUNT = 32;
    private static final int GRASS_TILE_ID = 5;
    private static final int INTERACTIVE_TILE_ID = 15;

    private final Image[] tileImages = new Image[TILE_COUNT];
    private Image[] buttonImages = new Image[3]; // For the three button icons
    
    private Image blueButtonImage;
    private Image iconsImage;
    private Image playImage;       // Play button image
    private Image pauseImage;      // Pause button image
    private Image accelerateImage; // Speed up image
    private Image settingsImage;   // Settings image
    private Button playPauseButton;
    private boolean isGamePlaying = true;
    private boolean isGameAccelerated = false;
    private boolean isEndGamePopupShown = false; // Flag to prevent multiple popups
    private Stage currentStage; // Store the stage reference
    private Pane root;
    private Canvas canvas;
    private GraphicsContext gc;
    private HBox buttonContainer;

    private GamePlayController controller;

    private EnemyView enemyView;
    // private TowerView towerView;

    private Image[] projectileImages = new Image[3]; // Array to store projectile images

    ArrayList<IEnemy> enemies;
    ArrayList<ITower> towers;
    // Projectiles projectiles;

    // Removed Enemiea Projectiles from here

    private ArrayList<IEnemy> deadEnemies;
    private ArrayList<IProjectile> deadProjectiles;

    ArrayList<IProjectile> projectiles;

    private int currentGold;
    private int currentHealth;
    private int currentWave;

    private Text goldText;
    private Text healthText;

    private int[][] map;
    
    public void start(Stage stage, GamePlayController controller) {
        
        loadTiles();
        loadButtonIcons();
        loadProjectileImages();

        this.currentStage = stage; // Store the stage
        this.isEndGamePopupShown = false; // Reset flag on start

        this.controller = controller;
        this.enemyView = new EnemyView(TILE_SIZE);  // Pass just the tile size
        // this.towerView = new TowerView(TILE_SIZE);  // Pass just the tile size

        this.enemies = controller.getGameManager().getEnemies();
        this.towers = controller.getGameManager().getTowers();

        this.deadEnemies = controller.getGameManager().getEnemiesToRemove();
        this.deadProjectiles = controller.getGameManager().getProjectilesToRemove();

        this.projectiles = controller.getGameManager().getProjectiles();
        this.currentGold = controller.getGameManager().getPlayer().getCurrentGold();
        this.currentHealth = controller.getGameManager().getPlayer().getCurrentHealth();
        this.currentWave = controller.getGameManager().getCurrentWaveIndex();

        controller.setGameUpdateListener(this);
        controller.setPlayerObserver(this);
        controller.setGameMapObserver(this);
        controller.startGame();

        map = GameMap.toIntArray(controller.getGameManager().getGameMap());

        // Create canvas with the calculated dimensions
        canvas = new Canvas(CANVAS_WIDTH, CANVAS_HEIGHT);
        gc = canvas.getGraphicsContext2D();
        drawMap(gc);
    
        // Create root pane to center the canvas
        root = new Pane();
        root.setPrefSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        
        // Position canvas in the center if it's smaller than the screen
        canvas.setLayoutX((SCREEN_WIDTH - CANVAS_WIDTH) / 2);
        canvas.setLayoutY(0); // Set to top of screen
        
        root.getChildren().add(canvas);
        
        addUIElements(stage);

       
    
        Scene scene = new Scene(root, SCREEN_WIDTH, SCREEN_HEIGHT);
        try {
            Image cursorImage = new Image(getClass().getResourceAsStream("/assets/ui/cursor.png"));
            if (cursorImage != null && !cursorImage.isError()) {
                ImageCursor customCursor = new ImageCursor(cursorImage,
                                                           cursorImage.getWidth() / 2,
                                                           cursorImage.getHeight() / 2);
                scene.setCursor(customCursor); // Set on scene (optional, but good practice)
                root.setCursor(customCursor);  // Set on root pane - this is often key
            }
        } catch (Exception e) {
            // Failed to load custom cursor, will use default cursor
            e.printStackTrace();
        }
        stage.setTitle("Game Map");
        stage.setScene(scene);
        stage.setMaximized(true);
        stage.show();
    
        setupClickHandler();
    }

    private void loadTiles() {
        for (int i = 0; i < TILE_COUNT; i++) {
            String path = "/assets/tiles/tile" + i + ".png";
            tileImages[i] = new Image(getClass().getResourceAsStream(path));
        }
    }

    private void loadButtonIcons() {
        // Load images for the buttons
        for (int i = 0; i < 3; i++) {
            
            String path;

            if (i == 0) {
                path = "/assets/buttons/star.png"; // First button icon
            } else if (i == 1) {
                path = "/assets/buttons/arrow.png"; // Second button icon
            } else {
                path = "/assets/buttons/bomb.png"; // Third button icon
            }

            buttonImages[i] = new Image(getClass().getResourceAsStream(path));
        }

        blueButtonImage = new Image(getClass().getResourceAsStream("/assets/ui/blue-button.png"));
        iconsImage = new Image(getClass().getResourceAsStream("/assets/ui/status-icons.png"));

        // Load control button images
        playImage = new Image(getClass().getResourceAsStream("/assets/buttons/play.png"));
        pauseImage = new Image(getClass().getResourceAsStream("/assets/buttons/pause.png"));
        accelerateImage = new Image(getClass().getResourceAsStream("/assets/buttons/accelerate.png"));
        settingsImage = new Image(getClass().getResourceAsStream("/assets/buttons/settings.png"));
    }

    private void loadProjectileImages() {
        projectileImages[0] = new Image(getClass().getResourceAsStream("/assets/projectiles/arrow.png")); // Arrow projectile
        projectileImages[1] = new Image(getClass().getResourceAsStream("/assets/projectiles/magic.png")); // Magic projectile
        projectileImages[2] = new Image(getClass().getResourceAsStream("/assets/projectiles/bomb.png")); // Artillery projectile
    }

    private void drawMap(GraphicsContext gc) {
        for (int row = 0; row < ROWS; row++) {
            for (int col = 0; col < COLS; col++) {
                // make grass background
                gc.drawImage(tileImages[GRASS_TILE_ID], col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                // place the items
                int tileId = map[row][col];
                if (tileId != GRASS_TILE_ID) {
                    gc.drawImage(tileImages[tileId], col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }
        }
    }

    private void setupClickHandler() {
        canvas.addEventHandler(MouseEvent.MOUSE_CLICKED, event -> {
            int col = (int) (event.getX() / TILE_SIZE);
            int row = (int) (event.getY() / TILE_SIZE);
    
            if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
                int tileId = map[row][col];
    
                if (tileId >= 20 && tileId <= 26) { // Tower tile IDs
                    showSellButton(row, col);
                } else if (tileId == INTERACTIVE_TILE_ID) { // Buildable tile
                    showBuildButtons(row, col);
                } else {
                    removeButtonContainer();
                }
            } else {
                removeButtonContainer();
            }
        });
    }

    private void removeButtonContainer() {
        if (buttonContainer != null) {
            root.getChildren().remove(buttonContainer);
            buttonContainer = null;
           
        }
    }
    private void showSellButton(int row, int col) {
        removeButtonContainer();
    
        buttonContainer = new HBox(10);
        buttonContainer.setAlignment(Pos.CENTER);
    
        // Calculate position based on clicked tile
        double tileLeftX = col * TILE_SIZE;
        double tileTopY = row * TILE_SIZE;
    
        // Position container centered above the clicked tile
        buttonContainer.setLayoutX(tileLeftX + (TILE_SIZE / 2) - 50); // Center minus half of button width
        buttonContainer.setLayoutY(tileTopY - 40); // Position above the tile
    
        Button sellButton = new Button("Sell");
        sellButton.setStyle("-fx-background-color: red; -fx-text-fill: white; -fx-font-weight: bold;");
        sellButton.setPrefSize(80, 30);
    
        sellButton.setOnAction(e -> {
            handleSellButtonClick(row, col);
        });
    
        buttonContainer.getChildren().add(sellButton);
        root.getChildren().add(buttonContainer);
    }

    private void handleSellButtonClick(int row, int col) {
        int tileId = map[row][col];
            int towerType;
            switch (tileId) {
                case 20: // Example: Tower type 0
                    towerType = 0;
                    break;
                case 21: // Example: Tower type 1
                    towerType = 1;
                    break;
                case 26: // Example: Tower type 2
                    towerType = 2;
                    break;
                default:
                    return;
            }
    
            // Call the controller's sellTower method with the tower type
            boolean success = controller.sellTower(col, row, towerType);
            if (success) {
            } else {
            }
    
           removeButtonContainer();
    }

    private void showBuildButtons(int row, int col) {
        removeButtonContainer();
    
        buttonContainer = new HBox(10);
        buttonContainer.setAlignment(Pos.CENTER);
    
        // Calculate position based on clicked tile
        double tileLeftX = col * TILE_SIZE;
        double tileTopY = row * TILE_SIZE;
    
        // Position container centered above the clicked tile
        buttonContainer.setLayoutX(tileLeftX + (TILE_SIZE / 2) - 105); // Center minus half of total buttons width
        buttonContainer.setLayoutY(tileTopY - 80); // Position above the tile
    
        // Create buttons for building towers
        for (int i = 0; i < 3; i++) {
            Button button = new Button();
            if (buttonImages[i] != null) {
                button.setGraphic(new ImageView(buttonImages[i]));
            }
            button.setStyle("-fx-background-color: transparent; -fx-padding: 5;");
            button.setPrefSize(64, 64);
    
            final int buttonId = i;
            button.setOnAction(e -> handleBuildButtonClick(buttonId, row, col));
    
            buttonContainer.getChildren().add(button);
        }
    
        root.getChildren().add(buttonContainer);
    }

    private void handleBuildButtonClick(int buttonId, int row, int col) {
        
        // Map button IDs to tower types (0=Magic/Star, 1=Artillery/Bomb, 2=Archer/Arrow)
        int towerType;
        switch(buttonId) {
            case 0: // Star button - creates Magic tower
                towerType = 1; // MAGIC tower type
                break;
            case 1: // Bomb button - creates Artillery tower
                towerType = 2; // ARTILLERY tower type
                break;
            case 2: // Arrow button - creates Archer tower
                towerType = 0; // ARROW tower type
                break;
            default:
                return;
        }
        
        // Tell the controller to build a tower of the selected type
        boolean success = controller.buildTower(col, row, towerType);

        
        if (success) {
        } else {
        }
        
        removeButtonContainer();
    }

    private void addUIElements(Stage stage) {
        VBox buttonColumn = new VBox(10); // Vertical layout with spacing
        buttonColumn.setLayoutX(64); // Next to icons
        buttonColumn.setLayoutY(10);

        goldText = new Text(""+currentGold);
        goldText.setFill(Color.WHITE);
        goldText.setFont(Font.font("Comic Sans MS", FontWeight.BOLD, 18));
        goldText.setTextOrigin(VPos.CENTER);

        healthText = new Text(""+currentHealth);
        healthText.setFill(Color.WHITE);
        healthText.setFont(Font.font("Comic Sans MS", FontWeight.BOLD, 18));
        healthText.setTextOrigin(VPos.CENTER);

        Text waveText = new Text(""+currentWave);
        waveText.setFill(Color.WHITE);
        waveText.setFont(Font.font("Comic Sans MS", FontWeight.BOLD, 18));
        waveText.setTextOrigin(VPos.CENTER);

        for (int i = 0; i < 3; i++) {
            ImageView blueButton = new ImageView(blueButtonImage);
            blueButton.setFitWidth(120);
            blueButton.setFitHeight(42);
            
            // For the first button (gold button), create a stack pane to overlay text and image
            if (i == 0) {
                StackPane goldButton = new StackPane();
                goldButton.getChildren().addAll(blueButton, goldText);
                StackPane.setAlignment(goldText, Pos.CENTER);
                
                // Add margin to adjust vertical position if needed
                StackPane.setMargin(goldText, new Insets(-10, 0, 0, 0)); // Adjust top margin as needed
                
                buttonColumn.getChildren().add(goldButton);
            } else {
                buttonColumn.getChildren().add(blueButton);
            }

            // Add the health and wave buttons
            if (i == 1) {
                StackPane healthButton = new StackPane();
                healthButton.getChildren().addAll(blueButton, healthText);
                StackPane.setAlignment(healthText, Pos.CENTER);
                StackPane.setMargin(healthText, new Insets(-10, 0, 0, 0));
                buttonColumn.getChildren().add(healthButton);
            } else if (i == 2) {
                StackPane waveButton = new StackPane();
                waveButton.getChildren().addAll(blueButton, waveText);
                StackPane.setAlignment(waveText, Pos.CENTER);
                StackPane.setMargin(waveText, new Insets(-10, 0, 0, 0));
                buttonColumn.getChildren().add(waveButton);
            }
        }  

        ImageView icons = new ImageView(iconsImage);
        icons.setFitWidth(48);
        icons.setFitHeight(48 * 3); // Match button height
        icons.setLayoutX(10);
        icons.setLayoutY(10);

        // Create control buttons for the top-right corner
        HBox controlButtons = createControlButtons(stage);
        // Position at top-right with a margin
        controlButtons.setLayoutX(CANVAS_WIDTH - 200); // Adjust based on total width of buttons
        controlButtons.setLayoutY(20);
 
        root.getChildren().addAll(icons, buttonColumn, controlButtons);
    }

    private HBox createControlButtons(Stage stage) {
        HBox container = new HBox(10); // 10 pixels spacing between buttons
        
        // Create play/pause button with initial play image and store reference
        playPauseButton = createControlButton(pauseImage);
        
        // Create accelerate button
        Button accelerateButton = createControlButton(accelerateImage);
        // Create settings button
        Button settingsButton = createControlButton(settingsImage);
        
        // Set up the play/pause toggle functionality
        playPauseButton.setOnAction(e -> {
            if (isGamePlaying) {
                // Currently playing, pause the game
                controller.pauseGame();
                ((ImageView)playPauseButton.getGraphic()).setImage(playImage);
                
                // Show pause menu
                showPauseMenu(stage);
            } else {
                // Currently paused, resume the game
                controller.resumeGame();
                ((ImageView)playPauseButton.getGraphic()).setImage(pauseImage);
            }
            isGamePlaying = !isGamePlaying;
        });
        
        // Set up accelerate button
        accelerateButton.setOnAction(e -> {
            if (isGameAccelerated) {
                // Currently accelerated, slow down the game
                controller.slowDownGame();
            } else {
                // Currently normal speed, speed up the game
                controller.speedUpGame();
            }
            isGameAccelerated = !isGameAccelerated;
        });

        // Set up settings button
        settingsButton.setOnAction(e -> {
            // Pause the game
            controller.pauseGame();
            isGamePlaying = false;
            ((ImageView)playPauseButton.getGraphic()).setImage(playImage);
            
            // Show pause menu
            showPauseMenu(stage);
        });
        
        container.getChildren().addAll(playPauseButton, accelerateButton, settingsButton);
        return container;
    }

    private Button createControlButton(Image image) {
        Button button = new Button();
        ImageView imageView = new ImageView(image);
        imageView.setFitWidth(52);
        imageView.setFitHeight(52);
        button.setGraphic(imageView);
        
        // Remove button background, padding, and border
        button.setStyle(
            "-fx-background-color: transparent;" +
            "-fx-background-insets: 0;" +
            "-fx-background-radius: 0;" +
            "-fx-padding: 0;" +
            "-fx-border-color: transparent;" +
            "-fx-border-width: 0;" +
            "-fx-focus-color: transparent;" +
            "-fx-faint-focus-color: transparent;"
        );
        
        // Keep the transparent style on hover
        button.setOnMouseEntered(e -> {
            button.setOpacity(0.8); // Slight transparency on hover for visual feedback
        });
        
        button.setOnMouseExited(e -> {
            button.setOpacity(1.0); // Restore full opacity
        });
        
        return button;
    }

    private void showPauseMenu(Stage stage) {
        // Create a semi-transparent overlay
        Pane overlay = new Pane();
        overlay.setPrefSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        overlay.setStyle("-fx-background-color: rgba(0, 0, 0, 0.7);");
        
        // Create the pause menu container
        VBox pauseMenu = new VBox(15);
        pauseMenu.setAlignment(Pos.CENTER);
        pauseMenu.setStyle(
            "-fx-background-color: rgba(50, 50, 50, 0.9);" +
            "-fx-background-radius: 15;" +
            "-fx-padding: 20px;"
        );
        pauseMenu.setMaxWidth(300);
        pauseMenu.setMaxHeight(250);
        
        // Create the pause menu title
        Text pauseTitle = new Text("GAME PAUSED");
        pauseTitle.setFont(Font.font("System", FontWeight.BOLD, 24));
        pauseTitle.setFill(Color.WHITE);
        
        // Create buttons
        Button resumeButton = createPauseMenuButton("Resume Game");
        Button mainMenuButton = createPauseMenuButton("Return to Main Menu");
        
        // Add action handlers
        resumeButton.setOnAction(event -> {
            // Resume game
            controller.resumeGame();
            root.getChildren().remove(overlay);
            
            // Update the play/pause button state using the class field
            ((ImageView)playPauseButton.getGraphic()).setImage(pauseImage);
            isGamePlaying = true;
        });
        
        mainMenuButton.setOnAction(event -> {
            // End the current game
            controller.endGame();
            
            // Return to main menu
            MainMenuView mainMenuView = new MainMenuView();
            mainMenuView.start(stage);
        });
        
        // Add all elements to the pause menu
        pauseMenu.getChildren().addAll(pauseTitle, resumeButton, mainMenuButton);
        
        // Center the pause menu on screen
        pauseMenu.setLayoutX((SCREEN_WIDTH - 300) / 2);
        pauseMenu.setLayoutY((SCREEN_HEIGHT - 250) / 2);
        
        // Add overlay and pause menu to the root
        overlay.getChildren().add(pauseMenu);
        root.getChildren().add(overlay);
    }
    
    private Button createPauseMenuButton(String text) {
        Button button = new Button(text);
        button.setPrefWidth(200);
        button.setPrefHeight(40);
        button.setFont(Font.font("System", FontWeight.BOLD, 14));
        
        button.setStyle(
            "-fx-background-color: rgb(0, 218, 142);" +
            "-fx-text-fill: white;" +
            "-fx-background-radius: 8px;"
        );
        
        button.setOnMouseEntered(e -> button.setStyle(
            "-fx-background-color: rgb(34, 220, 155);" + 
            "-fx-text-fill: white;" +
            "-fx-background-radius: 8px;"
        ));
        
        button.setOnMouseExited(e -> button.setStyle(
            "-fx-background-color: rgb(0, 218, 142);" +
            "-fx-text-fill: white;" +
            "-fx-background-radius: 8px;"
        ));
        
        return button;
    }

    private void showEndGamePopup(GameState state, Stage stage) {
        // Create a semi-transparent overlay
        Pane overlay = new Pane();
        overlay.setPrefSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        overlay.setStyle("-fx-background-color: rgba(0, 0, 0, 0.7);");

        // Create the end game menu container
        VBox endGameMenu = new VBox(15);
        endGameMenu.setAlignment(Pos.CENTER);
        endGameMenu.setStyle(
            "-fx-background-color: rgba(50, 50, 50, 0.9);" +
            "-fx-background-radius: 15;" +
            "-fx-padding: 20px;"
        );
        endGameMenu.setMaxWidth(350); // Slightly wider for longer text
        endGameMenu.setMaxHeight(300);

        // Create the end game title based on the state
        String titleText = (state == GameState.GAME_WON) ? "YOU WON!" : "YOU LOST!";
        Text endGameTitle = new Text(titleText);
        endGameTitle.setFont(Font.font("System", FontWeight.BOLD, 28));
        endGameTitle.setFill(Color.WHITE);

        // Create buttons
        Button playAgainButton = createPauseMenuButton("Play Again"); // Reuse styling
        Button mainMenuButton = createPauseMenuButton("Return to Main Menu"); // Reuse styling

        // Add action handlers
        playAgainButton.setOnAction(event -> {
            controller.endGame(); // Clean up the current game
            root.getChildren().remove(overlay); // Remove the popup
            GamePlayController newController = new GamePlayController(); // Create a new controller
            this.start(stage, newController); // Restart the game view with the new controller
        });

        mainMenuButton.setOnAction(event -> {
            controller.endGame(); // Clean up the current game
            root.getChildren().remove(overlay); // Remove the popup
            // Return to main menu
            MainMenuView mainMenuView = new MainMenuView();
            mainMenuView.start(stage);
        });

        // Add all elements to the end game menu
        endGameMenu.getChildren().addAll(endGameTitle, playAgainButton, mainMenuButton);

        // Center the end game menu on screen
        endGameMenu.setLayoutX((SCREEN_WIDTH - 350) / 2);
        endGameMenu.setLayoutY((SCREEN_HEIGHT - 300) / 2);

        // Add overlay and end game menu to the root
        overlay.getChildren().add(endGameMenu);
        root.getChildren().add(overlay);

        // Ensure the popup is brought to the front
        overlay.toFront();
    }

    // Method called by the controller to update the game view
    @Override
    public void onGameUpdate(double deltaTime) { 
        // This must be called on the JavaFX Application Thread 
        // So we wrap it in Platform.runLater
         Platform.runLater(() -> {
            updateView(deltaTime);

            // Check game state for win/loss condition
            GameState currentState = controller.getGameManager().getGameState();
            if (!isEndGamePopupShown && (currentState == GameState.GAME_WON || currentState == GameState.GAME_LOST)) {
                showEndGamePopup(currentState, currentStage);
                isEndGamePopupShown = true; // Set flag to true once popup is shown
            }
        });
    }

    private double pastTime = 0.0;

    private void updateView(double deltaTime) {

        // Check if the popup is already shown, if so, don't update the view further
        if (isEndGamePopupShown) {
            return;
        }

        pastTime += deltaTime;
        
        int imgNum = ((int) (pastTime * 6)) % 6;

        // GraphicsContext gc = canvas.getGraphicsContext2D();
        map = GameMap.toIntArray(controller.getGameManager().getGameMap());
        gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        drawMap(gc);

       

        for (IProjectile projectile : projectiles) {
            // Get the projectile's current position
            Point2D position = projectile.getCoordinate();
        
            // Transform model coordinates to view coordinates using the same scaling as for enemies
            double modelWidth = 1920;  // The width used in the model
            double scaleFactor = TILE_SIZE * COLS / modelWidth; // Calculate the scale factor
        
            // Scale positions from model space to view space
            double viewX = position.getX() * scaleFactor;
            double viewY = position.getY() * scaleFactor;
        
            // Determine the projectile type and select the corresponding image
            Image projectileImage = null;
            double imageSize = 20; // Default size for projectiles
            boolean shouldRotate = false;
        
            switch (projectile.getProjectileType()) {
                case ARROW:
                    projectileImage = projectileImages[0];
                    imageSize = 30; // Larger size for arrows
                    shouldRotate = true; // Arrows need to be rotated
                    break;
                case MAGIC:
                    projectileImage = projectileImages[1];
                    imageSize = 35; // Larger size for magic projectiles
                    break;
                case ARTILLERY:
                    projectileImage = projectileImages[2];
                    imageSize = 15; // Smaller size for bombs
                    break;
            }
        
            // Draw the projectile image if it exists
            if (projectileImage != null) {
                if (shouldRotate) {
                    // Calculate the rotation angle based on the speed vector
                    double angle = Math.toDegrees(Math.atan2(projectile.getSpeedVector().getY(), projectile.getSpeedVector().getX()));
        
                    // Save the current state of the GraphicsContext
                    gc.save();
        
                    // Translate to the center of the projectile
                    gc.translate(viewX, viewY);
        
                    // Rotate the canvas
                    gc.rotate(angle + 180);
        
                    // Draw the image centered at (0, 0) after translation
                    gc.drawImage(projectileImage, -imageSize / 2, -imageSize / 2, imageSize, imageSize);
        
                    // Restore the GraphicsContext to its original state
                    gc.restore();
                } else {
                    // Draw the image without rotation
                    gc.drawImage(projectileImage, viewX - imageSize / 2, viewY - imageSize / 2, imageSize, imageSize);
                }
            }
        }
        
        
        // End of projectile rendering

        // Draw enemies
        enemyView.renderEnemies(gc, enemies, imgNum);

        // Update explosion animations (AnimationTimer handles the rendering)


        
    }

   

    @Override
    public void update(Object arg) {
        currentGold = controller.getGameManager().getPlayer().getCurrentGold();
        currentHealth = controller.getGameManager().getPlayer().getCurrentHealth();
        
        goldText.setText(String.valueOf(currentGold));
        healthText.setText(String.valueOf(currentHealth));

        map = GameMap.toIntArray(controller.getGameManager().getGameMap());
        gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());
        drawMap(gc);
        double deltaTime = 0.0; // Placeholder for actual deltaTime
        updateView(deltaTime); // Pass a dummy deltaTime for now
    }
}
package com.kurabiye.kutd.view;

import javafx.application.Application;
import javafx.stage.Stage;

public class View extends Application {

    @Override
    public void start(Stage stage) {
        // Start the Launch Screen
        LaunchScreenView launchScreen = new LaunchScreenView();
        launchScreen.start(stage);
    }

    public static void main(String[] args) {
        launch(args);
    }
}
package com.kurabiye.kutd.view;

import javafx.animation.Animation;
import javafx.animation.FadeTransition;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.ProgressBar;
import javafx.scene.effect.DropShadow;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import javafx.util.Duration;

import java.util.Random;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class LoadingScreenView {

    private String[] loadingMessages = {
        "The blades are being sharpened...",
        "Goblins are meeting up...",
        "Archers are preparing their arrows...",
        "Magic shields are being cast...",
        "The castle gates are being closed...",
    };

    private ProgressBar progressBar;
    private Label messageLabel;
    private ScheduledExecutorService scheduler;
    private double progress = 0.0;
    private Stage stage; // Store the stage

    public void start(Stage stage) {
        this.stage = stage; // Save the stage reference

        BorderPane root = new BorderPane();

        // Load background image
        Image backgroundImage = new Image(getClass().getClassLoader().getResource("assets/castle_loadingbg.png").toExternalForm());
        ImageView backgroundView = new ImageView(backgroundImage);
        backgroundView.setFitWidth(600);
        backgroundView.setFitHeight(400);
        backgroundView.setPreserveRatio(false); // Fill the entire scene

        // Create game title with shadow effect
        Text titleText = new Text("KU TOWER DEFENSE");
        titleText.setFont(Font.font("System", FontWeight.BOLD, 44));
        titleText.setFill(Color.GOLD);

        DropShadow dropShadow = new DropShadow();
        dropShadow.setColor(Color.BLACK);
        dropShadow.setRadius(5.0);
        dropShadow.setOffsetX(2.0);
        dropShadow.setOffsetY(2.0);
        titleText.setEffect(dropShadow);

        // Select a random loading message
        Random random = new Random();
        String message = loadingMessages[random.nextInt(loadingMessages.length)];

        // Create a label with the selected message
        messageLabel = new Label(message);
        messageLabel.setFont(Font.font("System", 20));
        messageLabel.setTextFill(Color.WHITE);
        messageLabel.setEffect(new DropShadow(5, Color.BLACK));

        // Create a stylized progress bar
        progressBar = new ProgressBar(0);
        progressBar.setPrefWidth(300);
        progressBar.setStyle(
            "-fx-accent:rgb(0, 218, 142);" +
            "-fx-control-inner-background: #3c3b3f;" +
            "-fx-background-radius: 8;" +
            "-fx-border-radius: 8;" +
            "-fx-border-color:rgb(34, 220, 155);" +
            "-fx-border-width: 1px;"
        );

        // VBox to hold the components
        VBox vbox = new VBox(20);
        vbox.setAlignment(Pos.CENTER);
        vbox.getChildren().addAll(titleText, messageLabel, progressBar);
        vbox.setPadding(new Insets(20));

        // Animated enemies
        Pane enemiesPane = createAnimatedEnemies();

        // Stack all layers
        StackPane mainPane = new StackPane();
        mainPane.getChildren().addAll(backgroundView, enemiesPane, vbox);

        root.setCenter(mainPane);

        // Set the scene
        Scene scene = new Scene(root, 600, 400);
        stage.setTitle("Tower Defense - Loading...");
        stage.setScene(scene);
        stage.show();

        // Simulate loading with a progress bar
        //simulateLoading();
        
        MainMenuView mainMenuView = new MainMenuView();
        mainMenuView.start(stage);
    }

    private Pane createAnimatedEnemies() {
        Pane enemiesPane = new Pane();
        enemiesPane.setPrefSize(600, 400);

        Random random = new Random();
        for (int i = 0; i < 5; i++) {
            Circle enemy = new Circle(5 + random.nextInt(8));
            enemy.setFill(Color.rgb(255, 80, 80, 0.9));
            enemy.setCenterX(-20);
            enemy.setCenterY(50 + random.nextInt(300));
            enemy.setStroke(Color.BLACK);
            enemiesPane.getChildren().add(enemy);

            Timeline timeline = new Timeline(
                new KeyFrame(Duration.ZERO,
                    new KeyValue(enemy.centerXProperty(), -20)),
                new KeyFrame(Duration.seconds(5 + random.nextInt(10)),
                    new KeyValue(enemy.centerXProperty(), 620))
            );
            timeline.setCycleCount(Animation.INDEFINITE);
            timeline.play();
        }

        return enemiesPane;
    }

    private void simulateLoading() {
        scheduler = Executors.newScheduledThreadPool(1);

        scheduler.scheduleAtFixedRate(() -> {
            if (progress >= 1.0) {
                scheduler.shutdown();
                Platform.runLater(this::loadingComplete);
                return;
            }

            progress += 0.01 + (Math.random() * 0.01);
            if (progress > 1.0) progress = 1.0;

            Platform.runLater(() -> {
                progressBar.setProgress(progress);

                if ((progress > 0.3 && progress < 0.32) ||
                    (progress > 0.6 && progress < 0.62) ||
                    (progress > 0.8 && progress < 0.82)) {
                    Random random = new Random();
                    messageLabel.setText(loadingMessages[random.nextInt(loadingMessages.length)]);

                    Timeline timeline = new Timeline(
                        new KeyFrame(Duration.ZERO,
                            new KeyValue(messageLabel.scaleXProperty(), 1.0),
                            new KeyValue(messageLabel.scaleYProperty(), 1.0)),
                        new KeyFrame(Duration.millis(150),
                            new KeyValue(messageLabel.scaleXProperty(), 1.2),
                            new KeyValue(messageLabel.scaleYProperty(), 1.2)),
                        new KeyFrame(Duration.millis(300),
                            new KeyValue(messageLabel.scaleXProperty(), 1.0),
                            new KeyValue(messageLabel.scaleYProperty(), 1.0))
                    );
                    timeline.play();
                }
            });
        }, 0, 100, TimeUnit.MILLISECONDS);
    }

    private void loadingComplete() {
        Rectangle flashOverlay = new Rectangle(0, 0, 600, 400);
        flashOverlay.setFill(Color.WHITE);
        flashOverlay.setOpacity(0);

        Scene scene = progressBar.getScene();
        ((StackPane) ((BorderPane) scene.getRoot()).getCenter()).getChildren().add(flashOverlay);

        FadeTransition flash = new FadeTransition(Duration.millis(200), flashOverlay);
        flash.setFromValue(0);
        flash.setToValue(0.8);
        flash.setCycleCount(2);
        flash.setAutoReverse(true);

        flash.setOnFinished(event -> {
            // After flashing, go to MapView
            MainMenuView mainMenuView = new MainMenuView();
            mainMenuView.start(stage);
            ((StackPane) ((BorderPane) scene.getRoot()).getCenter()).getChildren().remove(flashOverlay);
        });

        flash.play();

        messageLabel.setText("Welcome to Tower Defense!");
    }

    public void shutdown() {
        if (scheduler != null && !scheduler.isShutdown()) {
            scheduler.shutdown();
        }
    }
}package com.kurabiye.kutd.view;

import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.Tooltip;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.stage.Stage;

import com.kurabiye.kutd.model.Map.GameMap;
import com.kurabiye.kutd.model.Tile.Tile;
import com.kurabiye.kutd.model.Tile.TileFactory;

/**
 *  MapEditorView
 */
public class MapEditorView {

    private static final int TILE_SIZE = 64;
    private static final int ROWS = 9;
    private static final int COLS = 16;
    private static final int BUTTON_SIZE = 48;

    private final Image[] tileImages = new Image[32]; //0-31 tile images
    private int[][] mapData;
    private int selectedTileType = 15; //default to buildable tile

    private Canvas canvas;
    private GraphicsContext gc;
    private Label statusLabel;

    public void start(Stage stage) {
        loadTileImages();
        initializeMapData();

        BorderPane root = new BorderPane();
        root.setStyle("-fx-background-color: #2D2D2D;");

        //create the canvas for map editing
        canvas = new Canvas(COLS * TILE_SIZE, ROWS * TILE_SIZE);
        gc = canvas.getGraphicsContext2D();
        drawMap();

        //create tile selection panel with scroll
        ScrollPane tileSelectionPanel = createTileSelectionPanel();
        tileSelectionPanel.setPrefWidth(200);

        //control buttons
        HBox controlButtons = createControlButtons(stage);

        //status bar
        statusLabel = new Label("Selected: Buildable Tile (15)");
        statusLabel.setFont(Font.font("System", FontWeight.BOLD, 14));
        statusLabel.setTextFill(Color.WHITE);
        statusLabel.setStyle("-fx-background-color: #333333; -fx-padding: 5px;");

        //layout setup
        Pane canvasContainer = new Pane(canvas);
        root.setCenter(canvasContainer);
        root.setLeft(tileSelectionPanel);
        root.setBottom(controlButtons);
        root.setTop(statusLabel);

        setupMouseHandlers();

        Scene scene = new Scene(root, COLS * TILE_SIZE + 250, ROWS * TILE_SIZE + 100);
        stage.setTitle("Map Editor");
        stage.setScene(scene);
        stage.show();
    }

    private void loadTileImages() {
        for (int i = 0; i < 32; i++) {
            String path = "/assets/tiles/tile" + i + ".png";
            try {
                tileImages[i] = new Image(getClass().getResourceAsStream(path));
            } catch (Exception e) {
                System.err.println("Failed to load tile image: " + path);
                tileImages[i] = createFallbackTileImage(i);
            }
        }
    }

    private Image createFallbackTileImage(int tileCode) {
        Canvas canvas = new Canvas(TILE_SIZE, TILE_SIZE);
        GraphicsContext gc = canvas.getGraphicsContext2D();

        //colors for different tile types
        if (tileCode == 15) {
            gc.setFill(Color.LIGHTGRAY); //buildable
        } else if (tileCode >= 0 && tileCode <= 14) {
            gc.setFill(Color.SANDYBROWN); //path
        } else if (tileCode == 5) {
            gc.setFill(Color.DARKGREEN); //ground
        } else {
            gc.setFill(Color.GRAY); //other
        }

        gc.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
        gc.setStroke(Color.BLACK);
        gc.strokeRect(0, 0, TILE_SIZE, TILE_SIZE);
        gc.setFill(Color.BLACK);
        gc.fillText("" + tileCode, 10, 20);

        return canvas.snapshot(null, null);
    }

    private ScrollPane createTileSelectionPanel() {
        GridPane gridPane = new GridPane();
        gridPane.setHgap(0);
        gridPane.setVgap(0);

        //calc dimensions
        int columns = 4;
        int buttonSize = BUTTON_SIZE;
        int panelWidth = columns * buttonSize;
        int rowsNeeded = (int) Math.ceil(32 / (double) columns);
        int panelHeight = rowsNeeded * buttonSize;

        //buttons in 4-column grid
        int count = 0;
        for (int i = 0; i < 32; i++) {
            Button tileButton = createTileButton(i);
            int row = count / columns;
            int col = count % columns;
            gridPane.add(tileButton, col, row);
            count++;
        }

        //create scroll pane (scrolling disabled)
        ScrollPane scrollPane = new ScrollPane(gridPane);
        scrollPane.setFitToWidth(true);
        scrollPane.setFitToHeight(true);
        scrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);

        //fixed dimensions
        gridPane.setPrefWidth(panelWidth);
        gridPane.setMinWidth(panelWidth);
        gridPane.setMaxWidth(panelWidth);
        scrollPane.setPrefViewportWidth(panelWidth);
        scrollPane.setPrefViewportHeight(panelHeight);

        return scrollPane;
    }

    private Button createTileButton(int tileType) {
        ImageView imageView = new ImageView(tileImages[tileType]);
        imageView.setFitWidth(BUTTON_SIZE);
        imageView.setFitHeight(BUTTON_SIZE);

        Button button = new Button();
        button.setGraphic(imageView);
        button.setStyle(
            "-fx-background-color: transparent; " +
            "-fx-padding: 0; " +
            "-fx-border-width: 0; " +
            "-fx-background-insets: 0; " +
            "-fx-content-display: graphic-only;" //no label spacing
        );
        button.setTooltip(new Tooltip("Tile " + tileType + " - " + getTileTypeName(tileType)));

        button.setOnAction(e -> {
            selectedTileType = tileType;
            statusLabel.setText("Selected: " + getTileTypeName(tileType) + " (" + tileType + ")");
        });
        return button;
    }

    private String getTileTypeName(int tileType) {
        switch (tileType) {
            case 0:
                return "Path Start";
            case 5:
                return "Ground";
            case 15:
                return "Buildable";
            case 20:
                return "Basic Tower";
            case 21:
                return "Magic Tower";
            case 26:
                return "Archer Tower";
            default:
                if (tileType >= 0 && tileType <= 14)
                    return "Path";
                if (tileType >= 16 && tileType <= 31)
                    return "Decoration";
                return "Unknown";
        }
    }

    private void initializeMapData() {
        mapData = new int[ROWS][COLS];
        for (int row = 0; row < ROWS; row++) {
            for (int col = 0; col < COLS; col++) {
                mapData[row][col] = 5; //default to grass
            }
        }
    }

    private void drawMap() {
        for (int row = 0; row < ROWS; row++) {
            for (int col = 0; col < COLS; col++) {
                int tileId = mapData[row][col];
                if (tileId >= 0 && tileId < tileImages.length && tileImages[tileId] != null) {
                    gc.drawImage(tileImages[tileId], col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }
        }
    }

    private HBox createControlButtons(Stage stage) {
        HBox buttonBox = new HBox(10);
        buttonBox.setStyle("-fx-background-color: #444444; -fx-padding: 10px;");

        Button saveButton = createTextButton("Save Map", this::saveMap);
        Button loadButton = createTextButton("Load Map", this::loadMap);
        Button validateButton = createTextButton("Validate Map", this::validateMap);
        Button returnButton = createTextButton("Main Menu", () -> returnToMenu(stage));

        buttonBox.getChildren().addAll(saveButton, loadButton, validateButton, returnButton);
        return buttonBox;
    }

    private Button createTextButton(String text, Runnable action) {
        Button button = new Button(text);
        button.setStyle("-fx-base: #4CAF50; -fx-text-fill: white; -fx-font-weight: bold;");
        button.setOnAction(e -> action.run());
        return button;
    }

    private void setupMouseHandlers() {
        canvas.setOnMouseClicked(e -> handleMapClick(e.getX(), e.getY()));
        canvas.setOnMouseDragged(e -> handleMapClick(e.getX(), e.getY()));
    }

    /**
     * Handles mouse clicks on the map canvas to place tiles.
     * 
     * Requires:
     * - x and y coordinates must be within canvas bounds (0 <= x < canvasWidth, 0
     * <= y < canvasHeight)
     * - selectedTileType must be a valid tile type (0 <= selectedTileType < 32)
     * 
     * Modifies:
     * - Updates the mapData array at the calculated row and column
     * - Modifies the canvas graphics by redrawing the affected tile
     * 
     * Effects:
     * - The tile at the clicked position is changed to the selectedTileType
     * - The visual representation on the canvas is updated to reflect the change
     */
    private void handleMapClick(double x, double y) {
        int col = (int) (x / TILE_SIZE);
        int row = (int) (y / TILE_SIZE);

        if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
            mapData[row][col] = selectedTileType;
            drawMap();
        }
    }

    private void saveMap() {
        statusLabel.setText("Saving map... (TODO: Implement saving)");
    }

    private void loadMap() {
        statusLabel.setText("Loading map... (TODO: Implement loading)");
    }

    private void validateMap() {
        statusLabel.setText("Validating map... (TODO: Implement validation)");
    }

    private void returnToMenu(Stage stage) {
        new MainMenuView().start(stage);
    }

}package com.kurabiye.kutd.view;

import javafx.animation.FadeTransition;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.ParallelTransition;
import javafx.animation.PauseTransition;
import javafx.animation.SequentialTransition;
import javafx.animation.Timeline;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import javafx.util.Duration;

public class LaunchScreenView {

    public void start(Stage stage) {
        // Create layout with white background
        StackPane root = new StackPane();
        root.setStyle("-fx-background-color:rgb(33, 33, 33);");

        // Load all cookie PNG images
        Image cookieFullImage = new Image(getClass().getClassLoader().getResource("assets/cookie_full.png").toExternalForm());
        Image cookieBitten2Image = new Image(getClass().getClassLoader().getResource("assets/cookie_bitten2.png").toExternalForm());
        Image cookieBiteImage = new Image(getClass().getClassLoader().getResource("assets/cookie_bite.png").toExternalForm());
        
        // Create ImageViews for each cookie state
        ImageView cookieFull = new ImageView(cookieFullImage);
        ImageView cookieBitten = new ImageView(cookieBitten2Image);
        ImageView cookieBite = new ImageView(cookieBiteImage);
        
        // Set size for all cookie images
        double cookieSize = 200;
        cookieFull.setFitWidth(cookieSize);
        cookieBitten.setFitWidth(cookieSize);
        cookieBite.setFitWidth(cookieSize * 0.3); // Bite is smaller
        
        // Preserve aspect ratio
        cookieFull.setPreserveRatio(true);
        cookieBitten.setPreserveRatio(true);
        cookieBite.setPreserveRatio(true);
        
        // Initially only show the full cookie
        cookieFull.setOpacity(1);
        cookieBitten.setOpacity(0);
        cookieBite.setOpacity(0);
        
        // Position the bite piece to start from the cookie
        cookieBite.setTranslateX(30);
        cookieBite.setTranslateY(-20);
        
        // Create text for company name
        Text companyName = new Text("KUrabiye Games");
        companyName.setFont(Font.font("Arial", FontWeight.BOLD, 36));
        companyName.setFill(Color.rgb(210, 150, 75)); // Cookie-like brown color
        companyName.setOpacity(0); // Start invisible
        companyName.setTranslateY(cookieSize / 2 + 40); // Position below cookie
        
        // Add all elements to the layout
        root.getChildren().addAll(cookieFull, cookieBitten, cookieBite, companyName);
        
        // Create animation sequence
        
        // Show full cookie for a moment
        PauseTransition initialPause = new PauseTransition(Duration.seconds(0.8));
        
        // Transition to bitten cookie and animate bite piece
        FadeTransition fadeOutFull = new FadeTransition(Duration.millis(150), cookieFull);
        fadeOutFull.setFromValue(1.0);
        fadeOutFull.setToValue(0.0);
        
        FadeTransition fadeInBitten = new FadeTransition(Duration.millis(150), cookieBitten);
        fadeInBitten.setFromValue(0.0);
        fadeInBitten.setToValue(1.0);
        
        // Animate the bite piece moving away
        Timeline moveBite = new Timeline();
        moveBite.getKeyFrames().add(
            new KeyFrame(Duration.ZERO, 
                new KeyValue(cookieBite.opacityProperty(), 0),
                new KeyValue(cookieBite.translateXProperty(), 30),
                new KeyValue(cookieBite.translateYProperty(), -20),
                new KeyValue(cookieBite.rotateProperty(), 0)
            )
        );
        moveBite.getKeyFrames().add(
            new KeyFrame(Duration.millis(100), 
                new KeyValue(cookieBite.opacityProperty(), 1)
            )
        );
        moveBite.getKeyFrames().add(
            new KeyFrame(Duration.millis(800), 
                new KeyValue(cookieBite.translateXProperty(), 120),
                new KeyValue(cookieBite.translateYProperty(), -80),
                new KeyValue(cookieBite.rotateProperty(), 45)
            )
        );
        
        // Combine bite transitions
        ParallelTransition biteTransition = new ParallelTransition(
            fadeOutFull, 
            fadeInBitten,
            moveBite
        );
        
        // Fade in company name with a slight bounce effect
        Timeline showCompanyName = new Timeline();
        showCompanyName.getKeyFrames().addAll(
            new KeyFrame(Duration.ZERO, 
                new KeyValue(companyName.opacityProperty(), 0),
                new KeyValue(companyName.scaleXProperty(), 0.8),
                new KeyValue(companyName.scaleYProperty(), 0.8)
            ),
            new KeyFrame(Duration.millis(500), 
                new KeyValue(companyName.opacityProperty(), 1),
                new KeyValue(companyName.scaleXProperty(), 1.1),
                new KeyValue(companyName.scaleYProperty(), 1.1)
            ),
            new KeyFrame(Duration.millis(700), 
                new KeyValue(companyName.scaleXProperty(), 1.0),
                new KeyValue(companyName.scaleYProperty(), 1.0)
            )
        );
        
        // Final pause before moving to loading screen
        PauseTransition finalPause = new PauseTransition(Duration.seconds(1.5));
        
        // Combine all animations in sequence
        SequentialTransition sequence = new SequentialTransition(
            initialPause,
            biteTransition,
            showCompanyName,
            finalPause
        );
        
        // After animation completes move to the Loading Screen
        sequence.setOnFinished(event -> {
            LoadingScreenView loadingScreen = new LoadingScreenView();
            loadingScreen.start(stage);
        });
        
        // Set the scene
        Scene scene = new Scene(root, 600, 400);
        stage.setTitle("KU Tower Defence - Launch Screen");
        stage.setScene(scene);
        stage.show();
        
        // Start the animation sequence
        sequence.play();
    }
}